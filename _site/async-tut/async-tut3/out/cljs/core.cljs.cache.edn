;; Analyzed by ClojureScript 0.0-2511
{:defs {->PersistentHashSet {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta hash-map __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentHashSet, :variadic false, :max-fixed-arity 3}), :line 7258, :end-line 7258, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, ->ExceptionInfo {:protocol-inline nil, :protocols #{}, :name cljs.core/->ExceptionInfo, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([message data cause]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 3}), :line 9058, :end-line 9058, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :skip-protocol-flag nil}, js->clj {:protocol-inline nil, :name cljs.core/js->clj, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x] [x opts]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 1}), :line 8554, :end-line 8554, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords."}, sort-by {:protocol-inline nil, :name cljs.core/sort-by, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([keyfn coll] [keyfn comp coll]), :protocol-impl nil, :column 1, :methods ({:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 2} {:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 3}), :line 1664, :end-line 1664, :max-fixed-arity 3, :fn-var true, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ITransientAssociative {:protocol-symbol true, :name cljs.core/ITransientAssociative, :file "out/cljs/core.cljs", :end-column 36, :column 1, :line 367, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 367, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}}, chunk-first {:protocol-inline nil, :name cljs.core/chunk-first, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 2687, :end-line 2687, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, m3-hash-int {:protocol-inline nil, :name cljs.core/m3-hash-int, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([in]), :protocol-impl nil, :column 1, :methods ({:tag #{nil number}, :variadic false, :max-fixed-arity 1}), :line 470, :ret-tag number, :end-line 470, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, stepper {:protocol-inline nil, :name cljs.core/stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([xform iter]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3084, :end-line 3084, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter]))}, pr-str* {:protocol-inline nil, :name cljs.core/pr-str*, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([obj]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 418, :end-line 418, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, eduction {:protocol-inline nil, :name cljs.core/eduction, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([xform coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Eduction, :variadic false, :max-fixed-arity 2}), :line 8500, :end-line 8500, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :doc "Returns a reducible/iterable/seqable application of\n  the transducer to the items in coll. Note that these applications\t\n  will be performed every time iterator/seq/reduce is called."}, tree-seq {:protocol-inline nil, :name cljs.core/tree-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([branch? children root]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3}), :line 3913, :end-line 3913, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree."}, unchecked-remainder-int {:protocol-inline nil, :name cljs.core/unchecked-remainder-int, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 1953, :end-line 1953, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n]))}, seq {:protocol-inline nil, :name cljs.core/seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 643, :ret-tag seq, :end-line 643, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "out/cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3530, :record false, :end-line 3530, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :name cljs.core/reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([f coll] [f val coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1698, :end-line 1698, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called."}, INIT {:file "out/cljs/core.cljs", :line 3033, :column 1, :end-line 3033, :end-column 11, :name cljs.core/INIT}, contains? {:protocol-inline nil, :name cljs.core/contains?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([coll v]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 1553, :ret-tag boolean, :end-line 1553, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, every? {:protocol-inline nil, :name cljs.core/every?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([pred coll]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3235, :ret-tag boolean, :end-line 3235, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, ->ES6IteratorSeq {:protocol-inline nil, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([value iter _rest]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ES6IteratorSeq, :variadic false, :max-fixed-arity 3}), :line 732, :end-line 732, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, Var {:num-fields 3, :protocols #{cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Var, :file "out/cljs/core.cljs", :end-column 14, :type true, :column 10, :line 624, :record false, :end-line 624, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IDeref}}, keep-indexed {:protocol-inline nil, :name cljs.core/keep-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f] [f coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 3552, :end-line 3552, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided."}, ->PersistentQueueSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([meta front rear __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentQueueSeq, :variadic false, :max-fixed-arity 4}), :line 4796, :end-line 4796, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, subs {:protocol-inline nil, :name cljs.core/subs, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([s start] [s start end]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 2148, :end-line 2148, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive."}, set {:protocol-inline nil, :name cljs.core/set, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7489, :end-line 7489, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, compare-indexed {:protocol-inline nil, :private true, :name cljs.core/compare-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([xs ys] [xs ys len n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2} {:tag number, :variadic false, :max-fixed-arity 4}), :line 1619, :end-line 1619, :max-fixed-arity 4, :fn-var true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection."}, take-last {:protocol-inline nil, :name cljs.core/take-last, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n coll]), :protocol-impl nil, :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 2}), :line 3766, :end-line 3766, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, IndexedSeq {:num-fields 2, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 938, :record false, :declared true, :end-line 938, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}}, bit-set {:protocol-inline nil, :name cljs.core/bit-set, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2065, :end-line 2065, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n"}, string-hash-cache-count {:file "out/cljs/core.cljs", :line 497, :column 1, :end-line 497, :end-column 30, :name cljs.core/string-hash-cache-count}, ->Eduction {:protocol-inline nil, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([xform coll]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Eduction, :variadic false, :max-fixed-arity 2}), :line 8485, :end-line 8485, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, tree-map-add {:protocol-inline nil, :private true, :name cljs.core/tree-map-add, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comp tree k v found]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil cljs.core/RedNode}, :variadic false, :max-fixed-arity 5}), :line 6776, :end-line 6776, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found]))}, ->ES6SetEntriesIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([s]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ES6SetEntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5087, :end-line 5087, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, -with-meta {:protocol-inline nil, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([o meta]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 304, :ret-tag clj, :end-line 305, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta]))}, reset-cache {:protocol-inline nil, :private true, :name cljs.core/reset-cache, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 8758, :end-line 8758, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, ->PersistentArrayMapIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 37, :method-params ([arr i cnt]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMapIterator, :variadic false, :max-fixed-arity 3}), :line 5237, :end-line 5237, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "out/cljs/core.cljs", :end-column 37, :type true, :column 10, :line 5237, :record false, :end-line 5237, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :name cljs.core/butlast, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 7553, :end-line 7553, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, ->t5588 {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t5588, :variadic false, :file "out/cljs/core.cljs", :method-params ([nil-iter meta5589]), :protocol-impl nil, :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t5588, :variadic false, :max-fixed-arity 2}), :line 3003, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta5589])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, tail-off {:protocol-inline nil, :private true, :name cljs.core/tail-off, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 4086, :end-line 4086, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, unchecked-subtract-int {:protocol-inline nil, :name cljs.core/unchecked-subtract-int, :variadic true, :file "out/cljs/core.cljs", :end-column 38, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1963, :ret-tag number, :end-line 1963, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -iterator {:protocol-inline nil, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 408, :end-line 409, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, take-nth {:protocol-inline nil, :name cljs.core/take-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n] [n coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7801, :end-line 7801, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided."}, first {:protocol-inline nil, :name cljs.core/first, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 666, :end-line 666, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, native-satisfies? {:protocol-inline nil, :name cljs.core/native-satisfies?, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([p x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 111, :ret-tag boolean, :end-line 111, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!"}, seq? {:protocol-inline nil, :name cljs.core/seq?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1527, :ret-tag boolean, :end-line 1527, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, -global-hierarchy {:file "out/cljs/core.cljs", :line 8648, :column 1, :end-line 8648, :end-column 34, :private true, :name cljs.core/-global-hierarchy}, UUID {:num-fields 1, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter}, :name cljs.core/UUID, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 9038, :record false, :end-line 9038, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter}}, -sorted-seq-from {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([coll k ascending?]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 334, :ret-tag clj, :end-line 336, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?]))}, println-str {:protocol-inline nil, :name cljs.core/println-str, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([objs]), :protocol-impl nil, :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8200, :end-line 8200, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "println to a string, returning it"}, linear-traversal-nth {:protocol-inline nil, :private true, :name cljs.core/linear-traversal-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 1163, :end-line 1163, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found]))}, iterate {:protocol-inline nil, :added "1.0", :name cljs.core/iterate, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f x]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2}), :line 3827, :end-line 3827, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"}, -empty {:protocol-inline nil, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 248, :end-line 249, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, newline {:protocol-inline nil, :name cljs.core/newline, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([opts]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 8158, :end-line 8158, :max-fixed-arity 1, :fn-var true, :arglists (quote ([opts]))}, ILookup {:protocol-symbol true, :name cljs.core/ILookup, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 269, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 269, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/TransientHashMap cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}}, -chunked-rest {:protocol-inline nil, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 386, :end-line 388, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, write-all {:protocol-inline nil, :name cljs.core/write-all, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([writer ss]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 1}), :line 8021, :end-line 8021, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer & ss]))}, fn? {:protocol-inline nil, :name cljs.core/fn?, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1328, :ret-tag boolean, :end-line 1328, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f]))}, -prefer-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 8810, :end-line 8814, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y]))}, -assoc {:protocol-inline nil, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll k v]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 272, :ret-tag clj, :end-line 275, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v]))}, doall {:protocol-inline nil, :name cljs.core/doall, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll] [n coll]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2}), :line 7938, :end-line 7938, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time."}, keyword-identical? {:protocol-inline nil, :name cljs.core/keyword-identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2465, :ret-tag boolean, :end-line 2465, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y]))}, pv-aset {:protocol-inline nil, :private true, :name cljs.core/pv-aset, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([node idx val]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 4080, :end-line 4080, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val]))}, prefers {:protocol-inline nil, :name cljs.core/prefers, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([multifn]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 9032, :end-line 9032, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, -js->clj {:protocol-inline nil, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x options]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 8551, :end-line 8552, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options]))}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 2495, :record false, :end-line 2495, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, dedupe {:protocol-inline nil, :name cljs.core/dedupe, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 0} {:tag any, :variadic false, :max-fixed-arity 1}), :line 8460, :end-line 8460, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided."}, unchecked-editable-array-for {:protocol-inline nil, :private true, :name cljs.core/unchecked-editable-array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 37, :method-params ([tv i]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 4647, :end-line 4647, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i]))}, ->ES6Iterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([s]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ES6Iterator, :variadic false, :max-fixed-arity 1}), :line 718, :end-line 718, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4072, :record false, :end-line 4072, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :name cljs.core/dissoc, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll] [coll k] [coll k ks]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj clj-nil}, :variadic true, :max-fixed-arity 2}), :line 1314, :end-line 1314, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s)."}, atom {:file "out/cljs/core.cljs", :line 5507, :column 1, :end-line 5507, :end-column 73, :declared true, :name cljs.core/atom}, bit-shift-right {:protocol-inline nil, :name cljs.core/bit-shift-right, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2079, :end-line 2079, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right"}, *clojurescript-version* {:file "out/cljs/core.cljs", :line 16, :column 1, :end-line 16, :end-column 30, :name cljs.core/*clojurescript-version*}, -first {:protocol-inline nil, :protocol cljs.core/ISeq, :name cljs.core/-first, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 262, :end-line 263, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, peek {:protocol-inline nil, :name cljs.core/peek, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1400, :end-line 1400, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, IKVReduce {:protocol-symbol true, :name cljs.core/IKVReduce, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 310, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 310, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentTreeMap}}, aget {:protocol-inline nil, :name cljs.core/aget, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([array i] [array i idxs]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 179, :end-line 179, :max-fixed-arity 2, :fn-var true, :arglists (quote ([array i] [array i & idxs])), :doc "Returns the value at the index."}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "out/cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6370, :record false, :end-line 6370, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :protocol cljs.core/IWriter, :name cljs.core/-write, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([writer s]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 340, :end-line 341, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s]))}, iter {:protocol-inline nil, :name cljs.core/iter, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any cljs.core/StringIter cljs.core/ArrayIter cljs.core/t5591 cljs.core/SeqIter}, :variadic false, :max-fixed-arity 1}), :line 3057, :end-line 3057, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, mk-bound-fn {:protocol-inline nil, :name cljs.core/mk-bound-fn, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([sc test key]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 3}), :line 7655, :end-line 7655, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key]))}, last {:protocol-inline nil, :name cljs.core/last, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1103, :end-line 1103, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, pr {:protocol-inline nil, :name cljs.core/pr, :variadic true, :file "out/cljs/core.cljs", :end-column 10, :method-params ([objs]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8173, :end-line 8173, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader"}, tree-map-seq-push {:protocol-inline nil, :private true, :name cljs.core/tree-map-seq-push, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([node stack ascending?]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 6363, :end-line 6363, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?]))}, namespace {:protocol-inline nil, :name cljs.core/namespace, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag string, :variadic false, :max-fixed-arity 1}), :line 2473, :end-line 2473, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, obj-map {:protocol-inline nil, :name cljs.core/obj-map, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([keyvals]), :protocol-impl nil, :column 1, :methods ({:variadic true, :max-fixed-arity 0}), :line 7048, :end-line 7048, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings."}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 825, :record false, :end-line 825, :skip-protocol-flag #{cljs.core/IDeref}}, -conj {:protocol-inline nil, :protocol cljs.core/ICollection, :name cljs.core/-conj, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll o]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 251, :ret-tag clj, :end-line 252, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o]))}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 6001, :record false, :end-line 6001, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :name cljs.core/=, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 699, :ret-tag boolean, :end-line 699, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison."}, ITransientMap {:protocol-symbol true, :name cljs.core/ITransientMap, :file "out/cljs/core.cljs", :end-column 28, :column 1, :line 370, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 370, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}}, push-tail {:protocol-inline nil, :private true, :name cljs.core/push-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pv level parent tailnode]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 4}), :line 4102, :end-line 4102, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode]))}, take {:protocol-inline nil, :name cljs.core/take, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n] [n coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3713, :end-line 3713, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided."}, vector? {:protocol-inline nil, :name cljs.core/vector?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1472, :ret-tag boolean, :end-line 1472, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, bitmap-indexed-node-index {:protocol-inline nil, :private true, :name cljs.core/bitmap-indexed-node-index, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([bitmap bit]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5533, :end-line 5533, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit]))}, boolean {:protocol-inline nil, :name cljs.core/boolean, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1539, :ret-tag boolean, :end-line 1539, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, IChunk {:protocol-symbol true, :name cljs.core/IChunk, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 383, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 383, :impls #{cljs.core/ArrayChunk}}, bit-shift-left {:protocol-inline nil, :name cljs.core/bit-shift-left, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2075, :end-line 2075, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left"}, rand-int {:protocol-inline nil, :name cljs.core/rand-int, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 8621, :end-line 8621, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, aclone {:protocol-inline nil, :name cljs.core/aclone, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([arr]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 162, :end-line 162, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, BlackNode {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 6529, :record false, :declared true, :end-line 6529, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, vreset! {:protocol-inline nil, :name cljs.core/vreset!, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([vol newval]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 3547, :end-line 3547, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, chunk {:protocol-inline nil, :name cljs.core/chunk, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([b]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2684, :end-line 2684, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, dec {:protocol-inline nil, :name cljs.core/dec, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1860, :end-line 1860, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num."}, map {:protocol-inline nil, :name cljs.core/map, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 colls]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 4}), :line 3666, :end-line 3666, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided."}, juxt {:protocol-inline nil, :name cljs.core/juxt, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f] [f g] [f g h] [f g h fs]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 7889, :end-line 7889, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]"}, < {:protocol-inline nil, :name cljs.core/<, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1812, :ret-tag boolean, :end-line 1812, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false."}, inode-kv-reduce {:protocol-inline nil, :private true, :name cljs.core/inode-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([arr f init]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 5550, :end-line 5550, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init]))}, obj-map->hash-map {:protocol-inline nil, :private true, :name cljs.core/obj-map->hash-map, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([m k v]), :protocol-impl nil, :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4939, :end-line 4939, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, test {:protocol-inline nil, :name cljs.core/test, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([v]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 1}), :line 9110, :end-line 9110, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, rest {:protocol-inline nil, :name cljs.core/rest, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 677, :ret-tag seq, :end-line 677, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, ex-data {:protocol-inline nil, :name cljs.core/ex-data, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9073, :end-line 9073, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "out/cljs/core.cljs", :end-column 32, :type true, :column 10, :line 5176, :record false, :end-line 5176, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 383, :end-line 384, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, isa? {:protocol-inline nil, :name cljs.core/isa?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([child parent] [h child parent]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic false, :max-fixed-arity 3}), :line 8658, :ret-tag boolean, :end-line 8658, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy"}, -clone {:protocol-inline nil, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([value]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 242, :ret-tag clj, :end-line 243, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value]))}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "out/cljs/core.cljs", :end-column 25, :type true, :column 10, :line 732, :record false, :end-line 732, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/NeverEquiv, :variadic false, :max-fixed-arity 0}), :line 4894, :end-line 4894, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}}, re-seq {:protocol-inline nil, :name cljs.core/re-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7983, :end-line 7983, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, make-hierarchy {:protocol-inline nil, :name cljs.core/make-hierarchy, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 8644, :end-line 8644, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, Symbol {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 579, :record false, :declared true, :end-line 579, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, tv-push-tail {:protocol-inline nil, :private true, :name cljs.core/tv-push-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([tv level parent tail-node]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/VectorNode}, :variadic false, :max-fixed-arity 4}), :line 4621, :end-line 4621, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node]))}, -reduce {:protocol-inline nil, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll f] [coll f start]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 307, :end-line 308, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f] [coll f start]))}, -count {:protocol-inline nil, :protocol cljs.core/ICounted, :name cljs.core/-count, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 245, :ret-tag number, :end-line 246, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll]))}, keep {:protocol-inline nil, :name cljs.core/keep, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f] [f coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3387, :end-line 3387, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided."}, char {:protocol-inline nil, :name cljs.core/char, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1880, :end-line 1880, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char"}, mapcat {:protocol-inline nil, :added "1.0", :name cljs.core/mapcat, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :static true, :method-params ([f] [f colls]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag #{nil any}, :variadic true, :max-fixed-arity 1}), :line 3866, :end-line 3866, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, unchecked-long {:protocol-inline nil, :name cljs.core/unchecked-long, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1990, :end-line 1990, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, m3-seed {:file "out/cljs/core.cljs", :line 451, :column 1, :end-line 451, :end-column 14, :name cljs.core/m3-seed}, some? {:protocol-inline nil, :name cljs.core/some?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 98, :ret-tag boolean, :end-line 98, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, unchecked-negate {:protocol-inline nil, :name cljs.core/unchecked-negate, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1945, :end-line 1945, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, reverse {:protocol-inline nil, :name cljs.core/reverse, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil seq any}, :variadic false, :max-fixed-arity 1}), :line 2337, :end-line 2337, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, range {:protocol-inline nil, :name cljs.core/range, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Range, :variadic false, :max-fixed-arity 0} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Range, :variadic false, :max-fixed-arity 3}), :line 7792, :end-line 7792, :max-fixed-arity 3, :fn-var true, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity."}, bit-count {:protocol-inline nil, :name cljs.core/bit-count, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([v]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2091, :end-line 2091, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, create-node {:protocol-inline nil, :private true, :name cljs.core/create-node, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/HashCollisionNode}, :variadic false, :max-fixed-arity 6} {:tag #{nil cljs.core/HashCollisionNode}, :variadic false, :max-fixed-arity 7}), :line 5983, :end-line 5983, :max-fixed-arity 7, :fn-var true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]))}, sort {:protocol-inline nil, :name cljs.core/sort, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll] [comp coll]), :protocol-impl nil, :column 1, :methods ({:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 1} {:tag #{seq cljs.core/IList}, :variadic false, :max-fixed-arity 2}), :line 1650, :end-line 1650, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ->MetaFn {:protocol-inline nil, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([afn meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/MetaFn, :variadic false, :max-fixed-arity 2}), :line 1331, :end-line 1331, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, unchecked-inc-int {:protocol-inline nil, :name cljs.core/unchecked-inc-int, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1928, :end-line 1928, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -compare {:protocol-inline nil, :protocol cljs.core/IComparable, :name cljs.core/-compare, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 380, :ret-tag number, :end-line 381, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y]))}, map-indexed {:protocol-inline nil, :name cljs.core/map-indexed, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([f coll]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3368, :end-line 3368, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item."}, array-list {:protocol-inline nil, :name cljs.core/array-list, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ArrayList, :variadic false, :max-fixed-arity 0}), :line 7602, :end-line 7602, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, rand-nth {:protocol-inline nil, :name cljs.core/rand-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 8625, :end-line 8625, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, comp {:protocol-inline nil, :name cljs.core/comp, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [f] [f g] [f g h] [f1 f2 f3 fs]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3287, :end-line 3287, :max-fixed-arity 3, :fn-var true, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc."}, array-chunk {:protocol-inline nil, :name cljs.core/array-chunk, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([arr] [arr off] [arr off end]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 1} {:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 2} {:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 3}), :line 2604, :end-line 2604, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr] [arr off] [arr off end]))}, bit-shift-right-zero-fill {:protocol-inline nil, :name cljs.core/bit-shift-right-zero-fill, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2083, :end-line 2083, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, -as-transient {:protocol-inline nil, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 360, :ret-tag clj, :end-line 361, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll]))}, dorun {:protocol-inline nil, :name cljs.core/dorun, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll] [n coll]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1} {:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 7925, :end-line 7925, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil."}, pr-sequential-writer {:protocol-inline nil, :name cljs.core/pr-sequential-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 7}), :line 8002, :end-line 8002, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll]))}, accumulating-seq-count {:protocol-inline nil, :private true, :name cljs.core/accumulating-seq-count, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1136, :end-line 1136, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IIndexed {:protocol-symbol true, :name cljs.core/IIndexed, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 257, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 257, :impls #{cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}}, disj {:protocol-inline nil, :name cljs.core/disj, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll] [coll k] [coll k ks]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj clj-nil}, :variadic true, :max-fixed-arity 2}), :line 1415, :end-line 1415, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, IPrintWithWriter {:protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "out/cljs/core.cljs", :end-column 31, :column 1, :line 344, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 344, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, ->UUID {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter}, :name cljs.core/->UUID, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([uuid]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/UUID, :variadic false, :max-fixed-arity 1}), :line 9038, :end-line 9038, :max-fixed-arity 1, :fn-var true, :arglists (quote ([uuid])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter}}, IVector {:protocol-symbol true, :name cljs.core/IVector, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 292, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 292, :impls #{cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}}, IIterable {:protocol-symbol true, :name cljs.core/IIterable, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 408, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 408, :impls #{cljs.core/PersistentArrayMap cljs.core/IndexedSeq cljs.core/PersistentVector cljs.core/Range}}, *2 {:file "out/cljs/core.cljs", :line 61, :column 1, :end-line 63, :end-column 6, :doc "bound in a repl thread to the second most recent value printed", :name cljs.core/*2}, Eduction {:num-fields 2, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "out/cljs/core.cljs", :end-column 19, :type true, :column 10, :line 8485, :record false, :end-line 8485, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :private true, :name cljs.core/pv-clone-node, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([node]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4083, :end-line 4083, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, cons {:protocol-inline nil, :name cljs.core/cons, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2}), :line 2408, :end-line 2408, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest."}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 7390, :record false, :end-line 7390, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, floats {:protocol-inline nil, :name cljs.core/floats, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2000, :end-line 2000, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, TransientVector {:num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4663, :record false, :declared true, :end-line 4663, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, pos? {:protocol-inline nil, :name cljs.core/pos?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2111, :ret-tag boolean, :end-line 2111, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false"}, fnil {:protocol-inline nil, :name cljs.core/fnil, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f x] [f x y] [f x y z]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic false, :max-fixed-arity 4}), :line 3345, :end-line 3345, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched."}, merge-with {:protocol-inline nil, :name cljs.core/merge-with, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f maps]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic true, :max-fixed-arity 1}), :line 7224, :end-line 7224, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."}, nthrest {:protocol-inline nil, :name cljs.core/nthrest, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll n]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 1247, :end-line 1247, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, sequential? {:protocol-inline nil, :name cljs.core/sequential?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1453, :ret-tag boolean, :end-line 1453, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, tree-map-replace {:protocol-inline nil, :private true, :name cljs.core/tree-map-replace, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([comp tree k v]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 4}), :line 6874, :end-line 6874, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v]))}, m3-mix-H1 {:protocol-inline nil, :name cljs.core/m3-mix-H1, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([h1 k1]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 458, :ret-tag number, :end-line 458, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1]))}, ->TransientArrayMap {:protocol-inline nil, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([editable? len arr]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/TransientArrayMap, :variadic false, :max-fixed-arity 3}), :line 5426, :end-line 5426, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, prim-seq {:protocol-inline nil, :name cljs.core/prim-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([prim] [prim i]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1008, :end-line 1008, :max-fixed-arity 2, :fn-var true, :arglists (quote ([prim] [prim i]))}, *print-level* {:file "out/cljs/core.cljs", :line 38, :column 1, :end-line 38, :end-column 30, :dynamic true, :name cljs.core/*print-level*}, shuffle {:protocol-inline nil, :name cljs.core/shuffle, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 1691, :end-line 1691, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, ChunkedSeq {:num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4406, :record false, :declared true, :end-line 4406, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, hash-keyword {:protocol-inline nil, :name cljs.core/hash-keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([k]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2419, :end-line 2419, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, find {:protocol-inline nil, :name cljs.core/find, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([coll k]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/IVector clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1564, :end-line 1564, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, alength {:protocol-inline nil, :name cljs.core/alength, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([array]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 193, :ret-tag number, :end-line 193, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, bit-xor {:protocol-inline nil, :name cljs.core/bit-xor, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2035, :end-line 2035, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Bitwise exclusive or"}, ->IndexedSeq {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr i]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/IndexedSeq, :variadic false, :max-fixed-arity 2}), :line 938, :end-line 938, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 4963, :record false, :end-line 4963, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :name cljs.core/unsigned-bit-shift-right, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2087, :end-line 2087, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "out/cljs/core.cljs", :end-column 32, :type true, :column 10, :line 5087, :record false, :end-line 5087, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :name cljs.core/neg?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2118, :ret-tag boolean, :end-line 2118, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 2359, :record false, :end-line 2359, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([mf dispatch-val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 8810, :end-line 8813, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val]))}, ->StringIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([s i]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/StringIter, :variadic false, :max-fixed-arity 2}), :line 3009, :end-line 3009, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil}, js-invoke {:protocol-inline nil, :name cljs.core/js-invoke, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj s args]), :protocol-impl nil, :column 1, :methods ({:variadic true, :max-fixed-arity 2}), :line 206, :end-line 206, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name."}, ->List {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([meta first rest count __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/List, :variadic false, :max-fixed-arity 5}), :line 2214, :end-line 2214, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, m3-mix-K1 {:protocol-inline nil, :name cljs.core/m3-mix-K1, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([k1]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 455, :ret-tag number, :end-line 455, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1]))}, unchecked-float {:protocol-inline nil, :name cljs.core/unchecked-float, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1895, :ret-tag number, :end-line 1895, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, undefined? {:protocol-inline nil, :name cljs.core/undefined?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1524, :ret-tag boolean, :end-line 1524, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, IMeta {:protocol-symbol true, :name cljs.core/IMeta, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 301, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 301, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/t5588 cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/t5591 cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, reduced? {:protocol-inline nil, :name cljs.core/reduced?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([r]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 834, :ret-tag boolean, :end-line 834, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, apply-to {:protocol-inline nil, :name cljs.core/apply-to, :variadic false, :file "out/cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 2923, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args]))}, disj! {:protocol-inline nil, :name cljs.core/disj!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([tcoll val] [tcoll val vals]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2908, :end-line 2908, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, -lookup {:protocol-inline nil, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o k] [o k not-found]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 269, :end-line 270, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o k] [o k not-found]))}, ICloneable {:protocol-symbol true, :name cljs.core/ICloneable, :file "out/cljs/core.cljs", :end-column 25, :column 1, :line 242, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 242, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}}, IEncodeClojure {:protocol-symbol true, :name cljs.core/IEncodeClojure, :file "out/cljs/core.cljs", :end-column 29, :column 1, :line 8551, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 8551, :impls #{}}, booleans {:protocol-inline nil, :name cljs.core/booleans, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1995, :end-line 1995, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, array-map-index-of-symbol? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([arr m k]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5120, :end-line 5120, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k]))}, ->ArrayList {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayList, :variadic false, :max-fixed-arity 1}), :line 7594, :end-line 7594, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil}, RSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 1023, :record false, :declared true, :end-line 1023, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, mask {:protocol-inline nil, :private true, :name cljs.core/mask, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([hash shift]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5515, :end-line 5515, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, int-array {:protocol-inline nil, :name cljs.core/int-array, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2721, :end-line 2721, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq]))}, find-and-cache-best-method {:protocol-inline nil, :private true, :name cljs.core/find-and-cache-best-method, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 7}), :line 8785, :end-line 8785, :max-fixed-arity 7, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, set? {:protocol-inline nil, :name cljs.core/set?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1442, :ret-tag boolean, :end-line 1442, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, iterable? {:protocol-inline nil, :name cljs.core/iterable?, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 634, :end-line 634, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, cat {:protocol-inline nil, :added "1.7", :name cljs.core/cat, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([rf]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8448, :end-line 8448, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction."}, ->ES6EntriesIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ES6EntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5074, :end-line 5074, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, divide {:file "out/cljs/core.cljs", :line 1803, :column 1, :end-line 1803, :end-column 17, :declared true, :name cljs.core/divide}, -pr-writer {:protocol-inline nil, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([o writer opts]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 344, :end-line 350, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts]))}, flush {:protocol-inline nil, :name cljs.core/flush, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 0}), :line 8029, :end-line 8029, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, set-from-indexed-seq {:protocol-inline nil, :name cljs.core/set-from-indexed-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([iseq]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7483, :end-line 7483, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq]))}, take-while {:protocol-inline nil, :name cljs.core/take-while, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred] [pred coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7636, :end-line 7636, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, vary-meta {:protocol-inline nil, :name cljs.core/vary-meta, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d args]), :protocol-impl nil, :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 4} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 5} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 6} {:tag #{clj cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 6}), :line 2975, :end-line 2975, :max-fixed-arity 6, :fn-var true, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata."}, INext {:protocol-symbol true, :name cljs.core/INext, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 266, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 266, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range}}, is_proto_ {:protocol-inline nil, :name cljs.core/is_proto_, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 121, :end-line 121, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, START {:file "out/cljs/core.cljs", :line 3034, :column 1, :end-line 3034, :end-column 12, :name cljs.core/START}, ICounted {:protocol-symbol true, :name cljs.core/ICounted, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 245, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 245, :impls #{nil cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, IMapEntry {:protocol-symbol true, :name cljs.core/IMapEntry, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 281, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 281, :impls #{cljs.core/BlackNode cljs.core/PersistentVector cljs.core/RedNode}}, <= {:protocol-inline nil, :name cljs.core/<=, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1824, :ret-tag boolean, :end-line 1824, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false."}, conj! {:protocol-inline nil, :name cljs.core/conj!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([] [coll] [tcoll val] [tcoll val vals]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2867, :end-line 2867, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [coll] [tcoll val] [tcoll val & vals])), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type."}, -pop {:protocol-inline nil, :protocol cljs.core/IStack, :name cljs.core/-pop, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 288, :ret-tag clj, :end-line 290, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll]))}, repeatedly {:protocol-inline nil, :name cljs.core/repeatedly, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [n f]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3820, :end-line 3820, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it"}, ->t5591 {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t5591, :variadic false, :file "out/cljs/core.cljs", :method-params ([nil-iter meta5592]), :protocol-impl nil, :anonymous true, :column 3, :factory :positional, :methods ({:tag cljs.core/t5591, :variadic false, :max-fixed-arity 2}), :line 3003, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta5592])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, zipmap {:protocol-inline nil, :name cljs.core/zipmap, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([keys vals]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 7568, :end-line 7568, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, IStack {:protocol-symbol true, :name cljs.core/IStack, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 288, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 288, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}}, -remove-watch {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([this key]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 355, :end-line 358, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key]))}, IVolatile {:protocol-symbol true, :name cljs.core/IVolatile, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 405, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 405, :impls #{cljs.core/Volatile}}, remove {:protocol-inline nil, :name cljs.core/remove, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([pred] [pred coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3905, :end-line 3905, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->BitmapIndexedNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->BitmapIndexedNode, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([edit bitmap arr]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/BitmapIndexedNode, :variadic false, :max-fixed-arity 3}), :line 5568, :end-line 5568, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag nil}, * {:protocol-inline nil, :name cljs.core/*, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1796, :ret-tag number, :end-line 1796, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1."}, re-pattern {:protocol-inline nil, :name cljs.core/re-pattern, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag #{nil js/RegExp}, :variadic false, :max-fixed-arity 1}), :line 7992, :end-line 7992, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, min {:protocol-inline nil, :name cljs.core/min, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1871, :ret-tag number, :end-line 1871, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums."}, array-map-index-of-nil? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-nil?, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr m k]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5101, :end-line 5101, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k]))}, -persistent! {:protocol-inline nil, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([tcoll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 363, :ret-tag clj, :end-line 365, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll]))}, -nth {:protocol-inline nil, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 257, :end-line 258, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found]))}, pop! {:protocol-inline nil, :name cljs.core/pop!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([tcoll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2902, :end-line 2902, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll"}, chunk-append {:protocol-inline nil, :name cljs.core/chunk-append, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([b x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 2681, :end-line 2681, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x]))}, prn-str {:protocol-inline nil, :name cljs.core/prn-str, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([objs]), :protocol-impl nil, :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8168, :end-line 8168, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)"}, IReversible {:protocol-symbol true, :name cljs.core/IReversible, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 331, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 331, :impls #{cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}}, reversible? {:protocol-inline nil, :name cljs.core/reversible?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2331, :ret-tag boolean, :end-line 2331, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll]))}, -realized? {:protocol-inline nil, :protocol cljs.core/IPending, :name cljs.core/-realized?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([d]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 352, :ret-tag boolean, :end-line 353, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d]))}, -add-watch {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([this key f]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 355, :end-line 357, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f]))}, -deref-with-timeout {:protocol-inline nil, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([o msec timeout-val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 298, :end-line 299, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val]))}, conj {:protocol-inline nil, :name cljs.core/conj, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [coll] [coll x] [coll x xs]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 1115, :end-line 1115, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type."}, -sorted-seq {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([coll ascending?]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 334, :ret-tag clj, :end-line 335, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?]))}, flatten1 {:protocol-inline nil, :private true, :name cljs.core/flatten1, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([colls]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 3852, :end-line 3852, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, transduce {:protocol-inline nil, :name cljs.core/transduce, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([xform f coll] [xform f init coll]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3} {:tag any, :variadic false, :max-fixed-arity 4}), :line 1763, :end-line 1763, :max-fixed-arity 4, :fn-var true, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."}, fixture1 {:file "out/cljs/core.cljs", :line 8408, :column 1, :end-line 8408, :end-column 15, :name cljs.core/fixture1}, -swap! {:protocol-inline nil, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4} {:tag #{nil any}, :variadic false, :max-fixed-arity 5}), :line 402, :end-line 403, :max-fixed-arity 5, :fn-var true, :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs]))}, *print-length* {:file "out/cljs/core.cljs", :line 37, :column 1, :end-line 37, :end-column 31, :dynamic true, :name cljs.core/*print-length*}, js-delete {:protocol-inline nil, :name cljs.core/js-delete, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([obj key]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 1493, :end-line 1493, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key]))}, truth_ {:protocol-inline nil, :name cljs.core/truth_, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 69, :end-line 69, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!"}, ->MultiFn {:protocol-inline nil, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/MultiFn, :variadic false, :max-fixed-arity 8}), :line 8822, :end-line 8822, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, key->js {:protocol-inline nil, :name cljs.core/key->js, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any string}, :variadic false, :max-fixed-arity 1}), :line 8520, :end-line 8520, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ->MultiStepper {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->MultiStepper, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([xform iters nexts]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/MultiStepper, :variadic false, :max-fixed-arity 3}), :line 3100, :end-line 3100, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters nexts])), :skip-protocol-flag nil}, IEncodeJS {:protocol-symbol true, :name cljs.core/IEncodeJS, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 8513, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 8513, :impls #{}}, new-path {:protocol-inline nil, :private true, :name cljs.core/new-path, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([edit level node]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 3}), :line 4092, :end-line 4092, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node]))}, compare-and-set! {:protocol-inline nil, :name cljs.core/compare-and-set!, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([a oldval newval]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 3}), :line 3506, :end-line 3506, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false."}, array-seq {:protocol-inline nil, :name cljs.core/array-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([array] [array i]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/IndexedSeq clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1015, :end-line 1015, :max-fixed-arity 2, :fn-var true, :arglists (quote ([array] [array i]))}, array-copy-downward {:protocol-inline nil, :private true, :name cljs.core/array-copy-downward, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([from i to j len]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 5}), :line 1504, :end-line 1504, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, pack-array-node {:protocol-inline nil, :private true, :name cljs.core/pack-array-node, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([array-node edit idx]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/BitmapIndexedNode, :variadic false, :max-fixed-arity 3}), :line 5766, :end-line 5766, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx]))}, interleave {:protocol-inline nil, :name cljs.core/interleave, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([c1 c2] [c1 c2 colls]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 2}), :line 3832, :end-line 3832, :max-fixed-arity 2, :fn-var true, :arglists (quote ([c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc."}, print-map {:protocol-inline nil, :name cljs.core/print-map, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([m print-one writer opts]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 4}), :line 8212, :end-line 8212, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts]))}, map? {:protocol-inline nil, :name cljs.core/map?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1465, :ret-tag boolean, :end-line 1465, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, m3-C1 {:file "out/cljs/core.cljs", :line 452, :column 1, :end-line 452, :end-column 12, :name cljs.core/m3-C1}, get {:protocol-inline nil, :name cljs.core/get, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([o k] [o k not-found]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1255, :end-line 1255, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present."}, identity {:protocol-inline nil, :name cljs.core/identity, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1753, :end-line 1753, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, into {:protocol-inline nil, :name cljs.core/into, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([to from] [to xform from]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3}), :line 3936, :end-line 3936, :max-fixed-arity 3, :fn-var true, :arglists (quote ([to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied."}, long {:protocol-inline nil, :name cljs.core/long, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1985, :end-line 1985, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, double {:protocol-inline nil, :name cljs.core/double, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1890, :ret-tag number, :end-line 1890, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, volatile? {:protocol-inline nil, :name cljs.core/volatile?, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3543, :end-line 3543, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 2563, :record false, :end-line 2563, :skip-protocol-flag #{cljs.core/ICounted}}, -key {:protocol-inline nil, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 281, :end-line 282, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, nfirst {:protocol-inline nil, :name cljs.core/nfirst, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 1088, :end-line 1088, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 413, :record false, :end-line 413, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :name cljs.core/meta, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o]), :protocol-impl nil, :column 1, :methods ({:tag #{clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1393, :end-line 1393, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, tv-editable-tail {:protocol-inline nil, :private true, :name cljs.core/tv-editable-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([tl]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 4616, :end-line 4616, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl]))}, -kv-reduce {:protocol-inline nil, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll f init]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 310, :end-line 311, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init]))}, IHash {:protocol-symbol true, :name cljs.core/IHash, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 316, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 316, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, bit-and-not {:protocol-inline nil, :name cljs.core/bit-and-not, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2047, :end-line 2047, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Bitwise and"}, -comparator {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 334, :end-line 338, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, unchecked-add-int {:protocol-inline nil, :name cljs.core/unchecked-add-int, :variadic true, :file "out/cljs/core.cljs", :end-column 33, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1905, :ret-tag number, :end-line 1905, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0."}, hash-ordered-coll {:protocol-inline nil, :name cljs.core/hash-ordered-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 33, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 762, :ret-tag number, :end-line 762, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, extend-object! {:protocol-inline nil, :private true, :name cljs.core/extend-object!, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([obj fn-map]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 2202, :end-line 2202, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implict this (via the this-as macro) will resolve to the\n  object that the function is attached."}, do-assoc {:protocol-inline nil, :private true, :name cljs.core/do-assoc, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv level node i val]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 5}), :line 4145, :end-line 4145, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val]))}, reset-meta! {:protocol-inline nil, :name cljs.core/reset-meta!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([iref m]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 8356, :end-line 8356, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, ->KeySeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([mseq _meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/KeySeq, :variadic false, :max-fixed-arity 2}), :line 7080, :end-line 7080, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IEquiv {:protocol-symbol true, :name cljs.core/IEquiv, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 313, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 313, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, tree-map-kv-reduce {:protocol-inline nil, :private true, :name cljs.core/tree-map-kv-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([node f init]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 3}), :line 6513, :end-line 6513, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init]))}, cycle {:protocol-inline nil, :name cljs.core/cycle, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 3800, :end-line 3800, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, -deref {:protocol-inline nil, :protocol cljs.core/IDeref, :name cljs.core/-deref, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 295, :end-line 296, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o]))}, empty? {:protocol-inline nil, :name cljs.core/empty?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1429, :ret-tag boolean, :end-line 1429, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, short {:protocol-inline nil, :name cljs.core/short, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1888, :ret-tag number, :end-line 1888, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, -clj->js {:protocol-inline nil, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8513, :end-line 8514, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -chunked-first {:protocol-inline nil, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 386, :end-line 387, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, filterv {:protocol-inline nil, :name cljs.core/filterv, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([pred coll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 3966, :end-line 3966, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, tv-editable-root {:protocol-inline nil, :private true, :name cljs.core/tv-editable-root, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([node]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4613, :end-line 4613, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, hash {:protocol-inline nil, :name cljs.core/hash, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any number}, :variadic false, :max-fixed-arity 1}), :line 526, :end-line 526, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o]))}, quot {:protocol-inline nil, :name cljs.core/quot, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n d]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2014, :end-line 2014, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, unchecked-double {:protocol-inline nil, :name cljs.core/unchecked-double, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1896, :ret-tag number, :end-line 1896, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ->ChunkedCons {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([chunk more meta __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkedCons, :variadic false, :max-fixed-arity 4}), :line 2612, :end-line 2612, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, ranged-iterator {:protocol-inline nil, :name cljs.core/ranged-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([v start end]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/RangedIterator, :variadic false, :max-fixed-arity 3}), :line 4181, :end-line 4181, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end]))}, ITransientVector {:protocol-symbol true, :name cljs.core/ITransientVector, :file "out/cljs/core.cljs", :end-column 31, :column 1, :line 373, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 373, :impls #{cljs.core/TransientVector}}, key {:protocol-inline nil, :name cljs.core/key, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([map-entry]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 7143, :end-line 7143, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, longs {:protocol-inline nil, :name cljs.core/longs, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2002, :end-line 2002, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, not= {:protocol-inline nil, :name cljs.core/not=, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2991, :ret-tag boolean, :end-line 2991, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))"}, string? {:protocol-inline nil, :name cljs.core/string?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 107, :ret-tag boolean, :end-line 107, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, es6-iterator {:protocol-inline nil, :name cljs.core/es6-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ES6Iterator, :variadic false, :max-fixed-arity 1}), :line 727, :end-line 727, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/Delay, :file "out/cljs/core.cljs", :end-column 16, :type true, :column 10, :line 8413, :record false, :end-line 8413, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, pr-str-with-opts {:protocol-inline nil, :name cljs.core/pr-str-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 2}), :line 8135, :end-line 8135, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, m3-C2 {:file "out/cljs/core.cljs", :line 453, :column 1, :end-line 453, :end-column 12, :name cljs.core/m3-C2}, ->Symbol {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Symbol, :variadic false, :max-fixed-arity 5}), :line 579, :end-line 579, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, *print-newline* {:file "out/cljs/core.cljs", :line 33, :column 1, :end-line 33, :end-column 32, :dynamic true, :name cljs.core/*print-newline*}, unchecked-multiply-int {:protocol-inline nil, :name cljs.core/unchecked-multiply-int, :variadic true, :file "out/cljs/core.cljs", :end-column 38, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1938, :ret-tag number, :end-line 1938, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1."}, chunk-rest {:protocol-inline nil, :name cljs.core/chunk-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 2690, :end-line 2690, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, remove-all-methods {:protocol-inline nil, :name cljs.core/remove-all-methods, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([multifn]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 9007, :end-line 9007, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, trampoline {:protocol-inline nil, :name cljs.core/trampoline, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [f args]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1} {:tag any, :variadic true, :max-fixed-arity 1}), :line 8599, :end-line 8599, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns."}, pr-opts {:protocol-inline nil, :private true, :name cljs.core/pr-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 40, :end-line 40, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *1 {:file "out/cljs/core.cljs", :line 57, :column 1, :end-line 59, :end-column 6, :doc "bound in a repl thread to the most recent value printed", :name cljs.core/*1}, vec {:protocol-inline nil, :name cljs.core/vec, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 4393, :end-line 4393, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, *print-meta* {:file "out/cljs/core.cljs", :line 35, :column 1, :end-line 35, :end-column 29, :dynamic true, :name cljs.core/*print-meta*}, -notify-watches {:protocol-inline nil, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([this oldval newval]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 355, :end-line 356, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval]))}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 8822, :record false, :end-line 8822, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, int {:protocol-inline nil, :name cljs.core/int, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1975, :end-line 1975, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, ->ValSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([mseq _meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ValSeq, :variadic false, :max-fixed-arity 2}), :line 7148, :end-line 7148, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, rand {:protocol-inline nil, :name cljs.core/rand, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([] [n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:tag number, :variadic false, :max-fixed-arity 1}), :line 8615, :end-line 8615, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive)."}, second {:protocol-inline nil, :name cljs.core/second, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1078, :end-line 1078, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, IEditableCollection {:protocol-symbol true, :name cljs.core/IEditableCollection, :file "out/cljs/core.cljs", :end-column 34, :column 1, :line 360, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 360, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}}, hash-combine {:protocol-inline nil, :name cljs.core/hash-combine, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([seed hash]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 549, :end-line 549, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash]))}, > {:protocol-inline nil, :name cljs.core/>, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1836, :ret-tag boolean, :end-line 1836, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false."}, -name {:protocol-inline nil, :protocol cljs.core/INamed, :name cljs.core/-name, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 393, :ret-tag string, :end-line 394, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x]))}, replace {:protocol-inline nil, :name cljs.core/replace, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([smap] [smap coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag #{nil any cljs.core/LazySeq}, :variadic false, :max-fixed-arity 2}), :line 7522, :end-line 7522, :max-fixed-arity 2, :fn-var true, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided."}, ->Subvec {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([meta v start end __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 5}), :line 4490, :end-line 4490, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, associative? {:protocol-inline nil, :name cljs.core/associative?, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1449, :ret-tag boolean, :end-line 1449, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, unchecked-int {:protocol-inline nil, :name cljs.core/unchecked-int, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1980, :end-line 1980, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, js-keys {:protocol-inline nil, :name cljs.core/js-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([obj]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 1488, :end-line 1488, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj]))}, t5588 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t5588, :file "out/cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3003, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 5074, :record false, :end-line 5074, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :name cljs.core/keyword?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2462, :ret-tag boolean, :end-line 2462, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, array-iter {:protocol-inline nil, :name cljs.core/array-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ArrayIter, :variadic false, :max-fixed-arity 1}), :line 3030, :end-line 3030, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, force {:protocol-inline nil, :name cljs.core/force, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8429, :end-line 8429, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, group-by {:protocol-inline nil, :name cljs.core/group-by, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([f coll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 8632, :end-line 8632, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, -rseq {:protocol-inline nil, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 331, :ret-tag clj, :end-line 332, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll]))}, prn {:protocol-inline nil, :name cljs.core/prn, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([objs]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8205, :end-line 8205, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline)."}, tv-pop-tail {:protocol-inline nil, :private true, :name cljs.core/tv-pop-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([tv level node]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/VectorNode clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4633, :end-line 4633, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node]))}, ->Atom {:protocol-inline nil, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([state meta validator watches]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Atom, :variadic false, :max-fixed-arity 4}), :line 3421, :end-line 3421, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, PersistentHashMap {:num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6119, :record false, :declared true, :end-line 6119, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unchecked-multiply {:protocol-inline nil, :name cljs.core/unchecked-multiply, :variadic true, :file "out/cljs/core.cljs", :end-column 34, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1931, :ret-tag number, :end-line 1931, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1."}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "out/cljs/core.cljs", :end-column 23, :type true, :column 10, :line 6064, :record false, :end-line 6064, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :name cljs.core/even?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([n]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3263, :ret-tag boolean, :end-line 3263, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, es6-iterator-seq {:protocol-inline nil, :name cljs.core/es6-iterator-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([iter]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 742, :end-line 742, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter]))}, unchecked-dec {:protocol-inline nil, :name cljs.core/unchecked-dec, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1912, :end-line 1912, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, hash-collision-node-find-index {:protocol-inline nil, :private true, :name cljs.core/hash-collision-node-find-index, :variadic false, :file "out/cljs/core.cljs", :end-column 39, :method-params ([arr cnt key]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5876, :end-line 5876, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key]))}, persistent-array-map-seq {:protocol-inline nil, :name cljs.core/persistent-array-map-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr i _meta]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/PersistentArrayMapSeq clj-nil}, :variadic false, :max-fixed-arity 3}), :line 5231, :end-line 5231, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta]))}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "out/cljs/core.cljs", :end-column 24, :type true, :column 10, :line 7691, :record false, :end-line 7691, :skip-protocol-flag nil}, MultiStepper {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/MultiStepper, :file "out/cljs/core.cljs", :end-column 23, :type true, :column 10, :line 3100, :record false, :end-line 3100, :skip-protocol-flag nil}, double-array {:protocol-inline nil, :name cljs.core/double-array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2761, :end-line 2761, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq]))}, ->EmptyList {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/EmptyList, :variadic false, :max-fixed-arity 1}), :line 2275, :end-line 2275, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, seq-reduce {:protocol-inline nil, :private true, :name cljs.core/seq-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([f coll] [f val coll]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1675, :end-line 1675, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f val coll]))}, spread {:protocol-inline nil, :name cljs.core/spread, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([arglist]), :protocol-impl nil, :column 1, :methods ({:tag #{seq cljs.core/Cons clj-nil}, :variadic false, :max-fixed-arity 1}), :line 2809, :end-line 2809, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist]))}, balance-left {:protocol-inline nil, :private true, :name cljs.core/balance-left, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([key val ins right]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6428, :end-line 6428, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right]))}, rseq {:protocol-inline nil, :name cljs.core/rseq, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2334, :ret-tag seq, :end-line 2334, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll]))}, ex-cause {:protocol-inline nil, :name cljs.core/ex-cause, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([ex]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9089, :end-line 9089, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, IReset {:protocol-symbol true, :name cljs.core/IReset, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 399, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 399, :impls #{}}, IEmptyableCollection {:protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "out/cljs/core.cljs", :end-column 35, :column 1, :line 248, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 248, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, array-map-index-of {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([m k]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5147, :end-line 5147, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k]))}, ex-message {:protocol-inline nil, :name cljs.core/ex-message, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([ex]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 9081, :end-line 9081, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, string-print {:protocol-inline nil, :name cljs.core/string-print, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 8025, :end-line 8025, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, float {:protocol-inline nil, :name cljs.core/float, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1889, :ret-tag number, :end-line 1889, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, fixture2 {:file "out/cljs/core.cljs", :line 8409, :column 1, :end-line 8409, :end-column 15, :name cljs.core/fixture2}, IRecord {:protocol-symbol true, :name cljs.core/IRecord, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 328, :protocol-info {:methods {}}, :info nil, :end-line 328, :impls #{}}, pr-str {:protocol-inline nil, :name cljs.core/pr-str, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([objs]), :protocol-impl nil, :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8163, :end-line 8163, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."}, first-array-for-longvec {:protocol-inline nil, :private true, :name cljs.core/first-array-for-longvec, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([pv]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 4121, :end-line 4121, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, es6-set-entries-iterator {:protocol-inline nil, :name cljs.core/es6-set-entries-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ES6SetEntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5096, :end-line 5096, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, concat {:protocol-inline nil, :name cljs.core/concat, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [x] [x y] [x y zs]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 0} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 2}), :line 2817, :end-line 2817, :max-fixed-arity 2, :fn-var true, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls."}, -methods {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([mf]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8810, :end-line 8816, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf]))}, IDerefWithTimeout {:protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "out/cljs/core.cljs", :end-column 32, :column 1, :line 298, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 298, :impls #{}}, symbol {:protocol-inline nil, :name cljs.core/symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([name] [ns name]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Symbol, :variadic false, :max-fixed-arity 2}), :line 613, :end-line 613, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name] [ns name]))}, to-array-2d {:protocol-inline nil, :name cljs.core/to-array-2d, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 2710, :end-line 2710, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 4490, :record false, :end-line 4490, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ExceptionInfo {:num-fields 3, :protocols #{}, :name cljs.core/ExceptionInfo, :file "out/cljs/core.cljs", :end-column 24, :type true, :column 10, :line 9058, :record false, :end-line 9058, :skip-protocol-flag nil}, mod {:protocol-inline nil, :name cljs.core/mod, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2009, :end-line 2009, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, ISet {:protocol-symbol true, :name cljs.core/ISet, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 285, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 285, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}}, pop {:protocol-inline nil, :name cljs.core/pop, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1407, :end-line 1407, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, IPending {:protocol-symbol true, :name cljs.core/IPending, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 352, :protocol-info {:methods {-realized? [[d]]}}, :info nil, :end-line 352, :impls #{cljs.core/Delay}}, -entry-key {:protocol-inline nil, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll entry]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 334, :end-line 337, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry]))}, pop-tail {:protocol-inline nil, :private true, :name cljs.core/pop-tail, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([pv level node]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/VectorNode clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4155, :end-line 4155, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node]))}, dissoc! {:protocol-inline nil, :name cljs.core/dissoc!, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tcoll key] [tcoll key ks]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag clj, :variadic true, :max-fixed-arity 2}), :line 2892, :end-line 2892, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s)."}, reductions {:protocol-inline nil, :name cljs.core/reductions, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f coll] [f init coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 3}), :line 7875, :end-line 7875, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init."}, indexed? {:protocol-inline nil, :name cljs.core/indexed?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 925, :ret-tag boolean, :end-line 925, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, - {:protocol-inline nil, :name cljs.core/-, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1789, :ret-tag number, :end-line 1789, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -equiv {:protocol-inline nil, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([o other]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 313, :ret-tag boolean, :end-line 314, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other]))}, ->RangeIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([i end step]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/RangeIterator, :variadic false, :max-fixed-arity 3}), :line 7691, :end-line 7691, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil}, ->ArrayNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNode, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([edit cnt arr]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayNode, :variadic false, :max-fixed-arity 3}), :line 5779, :end-line 5779, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag nil}, assoc! {:protocol-inline nil, :name cljs.core/assoc!, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([tcoll key val] [tcoll key val kvs]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic true, :max-fixed-arity 3}), :line 2880, :end-line 2880, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll."}, hash-set {:protocol-inline nil, :name cljs.core/hash-set, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([] [keys]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ISet, :variadic false, :max-fixed-arity 0} {:tag clj, :variadic true, :max-fixed-arity 0}), :line 7506, :end-line 7506, :max-fixed-arity 0, :fn-var true, :arglists (quote ([] [& keys]))}, reduce-kv {:protocol-inline nil, :name cljs.core/reduce-kv, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([f init coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 1741, :end-line 1741, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, reset! {:file "out/cljs/core.cljs", :line 5507, :column 1, :end-line 5507, :end-column 56, :declared true, :name cljs.core/reset!}, name {:protocol-inline nil, :name cljs.core/name, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 1}), :line 7559, :end-line 7559, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, ->RedNode {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([key val left right __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/RedNode, :variadic false, :max-fixed-arity 5}), :line 6633, :end-line 6633, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, unchecked-array-for {:protocol-inline nil, :private true, :name cljs.core/unchecked-array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([pv i]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 4129, :end-line 4129, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, Fn {:protocol-symbol true, :name cljs.core/Fn, :file "out/cljs/core.cljs", :end-column 17, :column 1, :line 214, :protocol-info {:methods {}}, :info nil, :end-line 214, :impls #{function cljs.core/MetaFn}}, ffirst {:protocol-inline nil, :name cljs.core/ffirst, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1083, :end-line 1083, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, sorted-set {:protocol-inline nil, :name cljs.core/sorted-set, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([keys]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 0}), :line 7510, :end-line 7510, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys."}, pr-with-opts {:protocol-inline nil, :private true, :name cljs.core/pr-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([objs opts]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 8152, :end-line 8152, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6883, :record false, :end-line 6883, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->PersistentTreeMap {:protocol-inline nil, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeMap, :variadic false, :max-fixed-arity 5}), :line 6883, :end-line 6883, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-reduce {:protocol-inline nil, :private true, :name cljs.core/array-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr f] [arr f val] [arr f val idx]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 888, :end-line 888, :max-fixed-arity 4, :fn-var true, :arglists (quote ([arr f] [arr f val] [arr f val idx]))}, counted? {:protocol-inline nil, :name cljs.core/counted?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 921, :ret-tag boolean, :end-line 921, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, println {:protocol-inline nil, :name cljs.core/println, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([objs]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8193, :end-line 8193, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)"}, assoc-in {:protocol-inline nil, :name cljs.core/assoc-in, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([m p__5776 v]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3}), :line 4018, :end-line 4018, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 7258, :record false, :end-line 7258, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, bit-test {:protocol-inline nil, :name cljs.core/bit-test, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2070, :end-line 2070, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n"}, TransientHashMap {:num-fields 5, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6258, :record false, :declared true, :end-line 6258, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->PersistentHashMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentHashMap, :variadic false, :max-fixed-arity 6}), :line 6119, :end-line 6119, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ISwap {:protocol-symbol true, :name cljs.core/ISwap, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 402, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 402, :impls #{}}, ChunkedCons {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 2612, :record false, :declared true, :end-line 2612, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, memoize {:protocol-inline nil, :name cljs.core/memoize, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8584, :end-line 8584, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, alter-meta! {:protocol-inline nil, :name cljs.core/alter-meta!, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([iref f args]), :protocol-impl nil, :column 1, :methods ({:variadic true, :max-fixed-arity 2}), :line 8347, :end-line 8347, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects"}, ->StringBufferWriter {:protocol-inline nil, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([sb]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/StringBufferWriter, :variadic false, :max-fixed-arity 1}), :line 413, :end-line 413, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}}, zero? {:protocol-inline nil, :name cljs.core/zero?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([n]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2115, :ret-tag boolean, :end-line 2115, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n]))}, tv-ensure-editable {:protocol-inline nil, :private true, :name cljs.core/tv-ensure-editable, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([edit node]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/VectorNode}, :variadic false, :max-fixed-arity 2}), :line 4608, :end-line 4608, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, *main-cli-fn* {:file "out/cljs/core.cljs", :line 125, :column 1, :end-line 129, :end-column 17, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments", :name cljs.core/*main-cli-fn*}, -assoc-n {:protocol-inline nil, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll n val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 292, :ret-tag clj, :end-line 293, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val]))}, unchecked-dec-int {:protocol-inline nil, :name cljs.core/unchecked-dec-int, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1915, :end-line 1915, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, hash-imap {:protocol-inline nil, :private true, :name cljs.core/hash-imap, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([m]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2181, :end-line 2181, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, dominates {:protocol-inline nil, :private true, :name cljs.core/dominates, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x y prefer-table]), :protocol-impl nil, :column 1, :methods ({:tag #{boolean clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8781, :end-line 8781, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, persistent! {:protocol-inline nil, :name cljs.core/persistent!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2860, :end-line 2860, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, set-print-fn! {:protocol-inline nil, :name cljs.core/set-print-fn!, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([f]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 28, :end-line 28, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, nnext {:protocol-inline nil, :name cljs.core/nnext, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1}), :line 1098, :end-line 1098, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "out/cljs/core.cljs", :end-column 14, :type true, :column 10, :line 5505, :record false, :end-line 5505, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :private true, :name cljs.core/balance-right, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([key val left ins]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6453, :end-line 6453, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins]))}, throw-no-method-error {:protocol-inline nil, :private true, :name cljs.core/throw-no-method-error, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([name dispatch-val]), :protocol-impl nil, :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 2}), :line 8819, :end-line 8819, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val]))}, add-watch {:protocol-inline nil, :name cljs.core/add-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([iref key f]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 8361, :end-line 8361, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, not-every? {:protocol-inline nil, :name cljs.core/not-every?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([pred coll]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3244, :ret-tag boolean, :end-line 3244, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, rem {:protocol-inline nil, :name cljs.core/rem, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2020, :end-line 2020, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, pr-sb-with-opts {:protocol-inline nil, :private true, :name cljs.core/pr-sb-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :column 1, :methods ({:tag goog/string.StringBuffer, :variadic false, :max-fixed-arity 2}), :line 8128, :end-line 8128, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts]))}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/BitmapIndexedNode, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5568, :record false, :end-line 5568, :skip-protocol-flag nil}, ->NodeSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/NodeSeq, :variadic false, :max-fixed-arity 5}), :line 6001, :end-line 6001, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, some {:protocol-inline nil, :name cljs.core/some, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([pred coll]), :protocol-impl nil, :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 3249, :end-line 3249, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, INamed {:protocol-symbol true, :name cljs.core/INamed, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 393, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 393, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}}, ->Box {:protocol-inline nil, :protocols #{}, :name cljs.core/->Box, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([val]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Box, :variadic false, :max-fixed-arity 1}), :line 5505, :end-line 5505, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil}, IReduce {:protocol-symbol true, :name cljs.core/IReduce, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 307, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 307, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, drop {:protocol-inline nil, :name cljs.core/drop, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([n] [n coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3738, :end-line 3738, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided."}, js-obj {:protocol-inline nil, :name cljs.core/js-obj, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [keyvals]), :protocol-impl nil, :column 1, :methods ({:tag object, :variadic false, :max-fixed-arity 0} {:tag any, :variadic true, :max-fixed-arity 0}), :line 1482, :end-line 1482, :max-fixed-arity 0, :fn-var true, :arglists (quote ([] [& keyvals]))}, ITransientCollection {:protocol-symbol true, :name cljs.core/ITransientCollection, :file "out/cljs/core.cljs", :end-column 35, :column 1, :line 363, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 363, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 3421, :record false, :end-line 3421, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :name cljs.core/nth, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 2} {:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 1183, :end-line 1183, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences."}, sorted? {:protocol-inline nil, :name cljs.core/sorted?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1457, :ret-tag boolean, :end-line 1457, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, nil? {:protocol-inline nil, :name cljs.core/nil?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 83, :ret-tag boolean, :end-line 83, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, split-at {:protocol-inline nil, :name cljs.core/split-at, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :line 3806, :end-line 3806, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, TransientHashSet {:num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7353, :record false, :declared true, :end-line 7353, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, array-map-extend-kv {:protocol-inline nil, :private true, :name cljs.core/array-map-extend-kv, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([m k v]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 3}), :line 5162, :end-line 5162, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, prn-str-with-opts {:protocol-inline nil, :name cljs.core/prn-str-with-opts, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([objs opts]), :protocol-impl nil, :column 1, :methods ({:tag #{nil string}, :variadic false, :max-fixed-arity 2}), :line 8143, :end-line 8143, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, not-native {:file "out/cljs/core.cljs", :line 74, :column 1, :end-line 74, :end-column 17, :name cljs.core/not-native}, random-sample {:protocol-inline nil, :name cljs.core/random-sample, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([prob] [prob coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 8477, :end-line 8477, :max-fixed-arity 2, :fn-var true, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided."}, select-keys {:protocol-inline nil, :name cljs.core/select-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([map keyseq]), :protocol-impl nil, :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7240, :end-line 7240, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, bit-and {:protocol-inline nil, :name cljs.core/bit-and, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2039, :end-line 2039, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Bitwise and"}, bounded-count {:protocol-inline nil, :private true, :name cljs.core/bounded-count, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([s n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2801, :end-line 2801, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s n]))}, update {:protocol-inline nil, :name cljs.core/update, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z more]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic false, :max-fixed-arity 6} {:tag clj, :variadic true, :max-fixed-arity 6}), :line 4054, :end-line 4054, :max-fixed-arity 6, :fn-var true, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value."}, gensym_counter {:file "out/cljs/core.cljs", :line 8394, :column 1, :end-line 8394, :end-column 21, :name cljs.core/gensym_counter}, list* {:protocol-inline nil, :name cljs.core/list*, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([args] [a args] [a b args] [a b c args] [a b c d more]), :protocol-impl nil, :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 3} {:tag cljs.core/Cons, :variadic false, :max-fixed-arity 4} {:tag cljs.core/Cons, :variadic true, :max-fixed-arity 4}), :line 2842, :end-line 2842, :max-fixed-arity 4, :fn-var true, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence."}, ->Keyword {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([ns name fqn _hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 4}), :line 2434, :end-line 2434, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, update-in {:protocol-inline nil, :name cljs.core/update-in, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([m p__5779 f] [m p__5780 f a] [m p__5781 f a b] [m p__5782 f a b c] [m p__5783 f a b c args]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic false, :max-fixed-arity 6} {:tag clj, :variadic true, :max-fixed-arity 6}), :line 4027, :end-line 4027, :max-fixed-arity 6, :fn-var true, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created."}, prefer-method {:protocol-inline nil, :name cljs.core/prefer-method, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 9017, :end-line 9017, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, hash-symbol {:protocol-inline nil, :private true, :name cljs.core/hash-symbol, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([sym]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 562, :end-line 562, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, ensure-reduced {:protocol-inline nil, :name cljs.core/ensure-reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/Reduced}, :variadic false, :max-fixed-arity 1}), :line 839, :end-line 839, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, edit-and-set {:protocol-inline nil, :private true, :name cljs.core/edit-and-set, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([inode edit i a] [inode edit i a j b]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 4} {:variadic false, :max-fixed-arity 6}), :line 5539, :end-line 5539, :max-fixed-arity 6, :fn-var true, :arglists (quote ([inode edit i a] [inode edit i a j b]))}, ->PersistentArrayMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMap, :variadic false, :max-fixed-arity 4}), :line 5246, :end-line 5246, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, instance? {:protocol-inline nil, :name cljs.core/instance?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([t o]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 556, :ret-tag boolean, :end-line 556, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([t o]))}, mix-collection-hash {:protocol-inline nil, :name cljs.core/mix-collection-hash, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([hash-basis count]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 750, :ret-tag number, :end-line 750, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, re-find {:protocol-inline nil, :name cljs.core/re-find, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([re s]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7969, :end-line 7969, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, run! {:protocol-inline nil, :name cljs.core/run!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([proc coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 8507, :end-line 8507, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, char-escapes {:file "out/cljs/core.cljs", :line 8032, :column 1, :end-line 8032, :end-column 29, :private true, :name cljs.core/char-escapes}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "out/cljs/core.cljs", :end-column 22, :type true, :column 10, :line 718, :record false, :end-line 718, :skip-protocol-flag nil}, val {:protocol-inline nil, :name cljs.core/val, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([map-entry]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 7211, :end-line 7211, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, unchecked-add {:protocol-inline nil, :name cljs.core/unchecked-add, :variadic true, :file "out/cljs/core.cljs", :end-column 29, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1898, :ret-tag number, :end-line 1898, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0."}, not {:protocol-inline nil, :name cljs.core/not, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 94, :ret-tag boolean, :end-line 94, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, -vreset! {:protocol-inline nil, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([o new-value]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 405, :end-line 406, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value]))}, fn->comparator {:protocol-inline nil, :private true, :name cljs.core/fn->comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([f]), :protocol-impl nil, :column 1, :methods ({:tag #{number function}, :variadic false, :max-fixed-arity 1}), :line 1634, :end-line 1634, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, with-meta {:protocol-inline nil, :name cljs.core/with-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([o meta]), :protocol-impl nil, :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1384, :end-line 1384, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, unreduced {:protocol-inline nil, :name cljs.core/unreduced, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 844, :end-line 844, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, type {:protocol-inline nil, :name cljs.core/type, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 131, :end-line 131, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, identical? {:protocol-inline nil, :name cljs.core/identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 78, :ret-tag boolean, :end-line 78, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, -namespace {:protocol-inline nil, :protocol cljs.core/INamed, :name cljs.core/-namespace, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 393, :ret-tag string, :end-line 395, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x]))}, unchecked-divide-int {:protocol-inline nil, :name cljs.core/unchecked-divide-int, :variadic true, :file "out/cljs/core.cljs", :end-column 36, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1918, :ret-tag number, :end-line 1918, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, swap-global-hierarchy! {:protocol-inline nil, :private true, :name cljs.core/swap-global-hierarchy!, :variadic true, :file "out/cljs/core.cljs", :end-column 31, :method-params ([f args]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 1}), :line 8655, :end-line 8655, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f & args]))}, max-key {:protocol-inline nil, :name cljs.core/max-key, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k x] [k x y] [k x y more]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic true, :max-fixed-arity 3}), :line 7580, :end-line 7580, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest."}, ->PersistentTreeSet {:protocol-inline nil, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([meta tree-map __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeSet, :variadic false, :max-fixed-arity 3}), :line 7390, :end-line 7390, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, ->ChunkBuffer {:protocol-inline nil, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([buf end]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkBuffer, :variadic false, :max-fixed-arity 2}), :line 2563, :end-line 2563, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}}, hash-string {:protocol-inline nil, :name cljs.core/hash-string, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :column 1, :methods ({:tag #{nil number}, :variadic false, :max-fixed-arity 1}), :line 517, :end-line 517, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7148, :record false, :end-line 7148, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([mf]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8810, :end-line 8817, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf]))}, set-validator! {:protocol-inline nil, :name cljs.core/set-validator!, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([iref val]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 3515, :end-line 3515, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, array-map-index-of-equiv? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-equiv?, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([arr m k]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5139, :end-line 5139, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k]))}, -meta {:protocol-inline nil, :protocol cljs.core/IMeta, :name cljs.core/-meta, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([o]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 301, :ret-tag clj-or-nil, :end-line 302, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o]))}, RedNode {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 6633, :record false, :declared true, :end-line 6633, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ->IndexedSeqIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([arr i]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/IndexedSeqIterator, :variadic false, :max-fixed-arity 2}), :line 929, :end-line 929, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, -add-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([mf dispatch-val method]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 8810, :end-line 8812, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method]))}, balance-left-del {:protocol-inline nil, :private true, :name cljs.core/balance-left-del, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([key val del right]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6475, :end-line 6475, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right]))}, swap! {:protocol-inline nil, :name cljs.core/swap!, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([a f] [a f x] [a f x y] [a f x y more]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4} {:tag #{nil any}, :variadic true, :max-fixed-arity 4}), :line 3484, :end-line 3484, :max-fixed-arity 4, :fn-var true, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in."}, vals {:protocol-inline nil, :name cljs.core/vals, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([hash-map]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/ValSeq clj-nil}, :variadic false, :max-fixed-arity 1}), :line 7205, :end-line 7205, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, -chunked-next {:protocol-inline nil, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 390, :end-line 391, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, unchecked-subtract {:protocol-inline nil, :name cljs.core/unchecked-subtract, :variadic true, :file "out/cljs/core.cljs", :end-column 34, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1956, :ret-tag number, :end-line 1956, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, remove-pair {:protocol-inline nil, :private true, :name cljs.core/remove-pair, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 2}), :line 5527, :end-line 5527, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i]))}, IMap {:protocol-symbol true, :name cljs.core/IMap, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 277, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 277, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}}, ->SeqIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([_seq _next]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/SeqIter, :variadic false, :max-fixed-arity 2}), :line 3036, :end-line 3036, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil}, sorted-set-by {:protocol-inline nil, :name cljs.core/sorted-set-by, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comparator keys]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic true, :max-fixed-arity 1}), :line 7515, :end-line 7515, :max-fixed-arity 1, :fn-var true, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator."}, PersistentVector {:num-fields 6, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "out/cljs/core.cljs", :end-column 27, :type true, :column 10, :line 4191, :record false, :end-line 4191, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :name cljs.core/cloneable?, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([value]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 640, :end-line 640, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value]))}, hash-string* {:protocol-inline nil, :name cljs.core/hash-string*, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 500, :end-line 500, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, key-test {:protocol-inline nil, :name cljs.core/key-test, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([key other]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 5509, :ret-tag boolean, :end-line 5509, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([key other]))}, ->LazyTransformer {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->LazyTransformer, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([stepper first rest meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/LazyTransformer, :variadic false, :max-fixed-arity 4}), :line 3145, :end-line 3145, :max-fixed-arity 4, :fn-var true, :arglists (quote ([stepper first rest meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}}, -reset {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([mf]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8810, :end-line 8811, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf]))}, true? {:protocol-inline nil, :name cljs.core/true?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1520, :ret-tag boolean, :end-line 1520, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, array {:protocol-inline nil, :name cljs.core/array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([var-args]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 171, :ret-tag array, :end-line 171, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, print {:protocol-inline nil, :name cljs.core/print, :variadic true, :file "out/cljs/core.cljs", :end-column 9, :method-params ([objs]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic true, :max-fixed-arity 0}), :line 8181, :end-line 8184, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, -peek {:protocol-inline nil, :protocol cljs.core/IStack, :name cljs.core/-peek, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 288, :end-line 289, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, ISeq {:protocol-symbol true, :name cljs.core/ISeq, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 262, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 262, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq}}, empty {:protocol-inline nil, :name cljs.core/empty, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1130, :end-line 1130, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, remove-method {:protocol-inline nil, :name cljs.core/remove-method, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([multifn dispatch-val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 9012, :end-line 9012, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 4796, :record false, :end-line 4796, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :private true, :name cljs.core/balance-right-del, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([key val left del]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6494, :end-line 6494, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del]))}, volatile! {:protocol-inline nil, :name cljs.core/volatile!, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Volatile, :variadic false, :max-fixed-arity 1}), :line 3538, :end-line 3538, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, / {:protocol-inline nil, :name cljs.core//, :variadic true, :file "out/cljs/core.cljs", :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1805, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, bitpos {:protocol-inline nil, :private true, :name cljs.core/bitpos, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([hash shift]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 5536, :end-line 5536, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, bit-or {:protocol-inline nil, :name cljs.core/bit-or, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2043, :end-line 2043, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Bitwise or"}, m3-fmix {:protocol-inline nil, :name cljs.core/m3-fmix, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([h1 len]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 461, :ret-tag number, :end-line 461, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len]))}, vector {:protocol-inline nil, :name cljs.core/vector, :variadic true, :file "out/cljs/core.cljs", :end-column 14, :method-params ([args]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj}, :variadic true, :max-fixed-arity 0}), :line 4399, :end-line 4399, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& args]))}, hash-coll {:protocol-inline nil, :private true, :name cljs.core/hash-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any number}, :variadic false, :max-fixed-arity 1}), :line 2171, :end-line 2171, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, clone-and-set {:protocol-inline nil, :private true, :name cljs.core/clone-and-set, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([arr i a] [arr i a j b]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 3} {:tag array, :variadic false, :max-fixed-arity 5}), :line 5518, :end-line 5518, :max-fixed-arity 5, :fn-var true, :arglists (quote ([arr i a] [arr i a j b]))}, array->transient-hash-map {:protocol-inline nil, :private true, :name cljs.core/array->transient-hash-map, :variadic false, :file "out/cljs/core.cljs", :end-column 34, :method-params ([len arr]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 5496, :end-line 5496, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr]))}, >= {:protocol-inline nil, :name cljs.core/>=, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1848, :ret-tag boolean, :end-line 1848, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false."}, ->TransientHashSet {:protocol-inline nil, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([transient-map]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/TransientHashSet, :variadic false, :max-fixed-arity 1}), :line 7353, :end-line 7353, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, drop-last {:protocol-inline nil, :name cljs.core/drop-last, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([s] [n s]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3761, :end-line 3761, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll"}, ->ArrayIter {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayIter, :variadic false, :max-fixed-arity 2}), :line 3021, :end-line 3021, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, object? {:protocol-inline nil, :name cljs.core/object?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 102, :ret-tag boolean, :end-line 102, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, ->ArrayNodeSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayNodeSeq, :variadic false, :max-fixed-arity 5}), :line 6064, :end-line 6064, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, tree-map-append {:protocol-inline nil, :private true, :name cljs.core/tree-map-append, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([left right]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/BlackNode cljs.core/RedNode}, :variadic false, :max-fixed-arity 2}), :line 6795, :end-line 6795, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right]))}, not-empty {:protocol-inline nil, :name cljs.core/not-empty, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 2998, :end-line 2998, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, distinct {:protocol-inline nil, :name cljs.core/distinct, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 7539, :end-line 7539, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed"}, partition {:protocol-inline nil, :name cljs.core/partition, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n coll] [n step coll] [n step pad coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4}), :line 3975, :end-line 3975, :max-fixed-arity 4, :fn-var true, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items."}, IMultiFn {:protocol-symbol true, :name cljs.core/IMultiFn, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 8810, :protocol-info {:methods {-reset [[mf]], -add-method [[mf dispatch-val method]], -remove-method [[mf dispatch-val]], -prefer-method [[mf dispatch-val dispatch-val-y]], -get-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]]}}, :info nil, :end-line 8810, :impls #{cljs.core/MultiFn}}, fix {:protocol-inline nil, :private true, :name cljs.core/fix, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([q]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 1970, :ret-tag number, :end-line 1970, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q]))}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 2275, :record false, :end-line 2275, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IAssociative {:protocol-symbol true, :name cljs.core/IAssociative, :file "out/cljs/core.cljs", :end-column 27, :column 1, :line 272, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 272, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}}, bit-flip {:protocol-inline nil, :name cljs.core/bit-flip, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2056, :end-line 2056, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n"}, long-array {:protocol-inline nil, :name cljs.core/long-array, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2741, :end-line 2741, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq]))}, descendants {:protocol-inline nil, :name cljs.core/descendants, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tag] [h tag]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8694, :end-line 8694, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships."}, imul {:protocol-inline nil, :name cljs.core/imul, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([a b]), :protocol-impl nil, :column 3, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 440, :ret-tag number, :end-line 440, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b]))}, ->Delay {:protocol-inline nil, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/->Delay, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([f value]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Delay, :variadic false, :max-fixed-arity 2}), :line 8413, :end-line 8413, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, array-for {:protocol-inline nil, :private true, :name cljs.core/array-for, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pv i]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 4140, :end-line 4140, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, merge {:protocol-inline nil, :name cljs.core/merge, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([maps]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic true, :max-fixed-arity 0}), :line 7216, :end-line 7216, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result."}, ISeqable {:protocol-symbol true, :name cljs.core/ISeqable, :file "out/cljs/core.cljs", :end-column 23, :column 1, :line 319, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 319, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, js-mod {:protocol-inline nil, :name cljs.core/js-mod, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([n d]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2004, :end-line 2004, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, integer? {:protocol-inline nil, :name cljs.core/integer?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([n]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1545, :ret-tag boolean, :end-line 1545, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is an integer."}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1331, :record false, :end-line 1331, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, mapv {:protocol-inline nil, :name cljs.core/mapv, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 colls]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 4} {:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 4}), :line 3950, :end-line 3950, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments."}, partition-all {:protocol-inline nil, :name cljs.core/partition-all, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n] [n coll] [n step coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 3}), :line 7605, :end-line 7605, :max-fixed-arity 3, :fn-var true, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided."}, partition-by {:protocol-inline nil, :name cljs.core/partition-by, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([f] [f coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 7825, :end-line 7825, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."}, array-map-index-of-identical? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-identical?, :variadic false, :file "out/cljs/core.cljs", :end-column 38, :method-params ([arr m k]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5131, :end-line 5131, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k]))}, ISequential {:protocol-symbol true, :name cljs.core/ISequential, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 322, :protocol-info {:methods {}}, :info nil, :end-line 322, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, ->LazySeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([meta fn s __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 4}), :line 2495, :end-line 2495, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, equiv-map {:protocol-inline nil, :private true, :name cljs.core/equiv-map, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 4903, :end-line 4903, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false."}, ->Volatile {:protocol-inline nil, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([state]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Volatile, :variadic false, :max-fixed-arity 1}), :line 3530, :end-line 3530, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}}, object-array {:protocol-inline nil, :name cljs.core/object-array, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 2781, :end-line 2781, :max-fixed-arity 2, :fn-var true, :arglists (quote ([size-or-seq] [size init-val-or-seq]))}, Keyword {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 2434, :record false, :declared true, :end-line 2434, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, derive {:protocol-inline nil, :name cljs.core/derive, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2} {:tag #{nil cljs.core/IMap clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8703, :end-line 8703, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, seq-iter {:protocol-inline nil, :name cljs.core/seq-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/SeqIter, :variadic false, :max-fixed-arity 1}), :line 3054, :end-line 3054, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IChunkedSeq {:protocol-symbol true, :name cljs.core/IChunkedSeq, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 386, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 386, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}}, special-symbol? {:protocol-inline nil, :name cljs.core/special-symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 9104, :ret-tag boolean, :end-line 9104, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, compare-keywords {:protocol-inline nil, :private true, :name cljs.core/compare-keywords, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([a b]), :protocol-impl nil, :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 2422, :end-line 2422, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, ancestors {:protocol-inline nil, :name cljs.core/ancestors, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([tag] [h tag]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8686, :end-line 8686, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, subseq {:protocol-inline nil, :name cljs.core/subseq, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :column 1, :methods ({:tag #{seq clj cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 5}), :line 7661, :end-line 7661, :max-fixed-arity 5, :fn-var true, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, LazyTransformer {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/LazyTransformer, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 3145, :record false, :declared true, :end-line 3145, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}}, gensym {:protocol-inline nil, :name cljs.core/gensym, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([] [prefix-string]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 0} {:tag #{nil cljs.core/Symbol}, :variadic false, :max-fixed-arity 1}), :line 8396, :end-line 8396, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'."}, -next {:protocol-inline nil, :protocol cljs.core/INext, :name cljs.core/-next, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 266, :ret-tag clj-or-nil, :end-line 267, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll]))}, ->HashCollisionNode {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->HashCollisionNode, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/HashCollisionNode, :variadic false, :max-fixed-arity 4}), :line 5885, :end-line 5885, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag nil}, delay? {:protocol-inline nil, :name cljs.core/delay?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8425, :ret-tag boolean, :end-line 8425, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, create-inode-seq {:protocol-inline nil, :private true, :name cljs.core/create-inode-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([nodes] [nodes i s]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/NodeSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/NodeSeq clj-nil}, :variadic false, :max-fixed-arity 3}), :line 6047, :end-line 6047, :max-fixed-arity 3, :fn-var true, :arglists (quote ([nodes] [nodes i s]))}, flatten {:protocol-inline nil, :name cljs.core/flatten, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 3928, :end-line 3928, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, -dissoc {:protocol-inline nil, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll k]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 277, :ret-tag clj, :end-line 279, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k]))}, doubles {:protocol-inline nil, :name cljs.core/doubles, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 2001, :end-line 2001, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -contains-key? {:protocol-inline nil, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll k]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 272, :ret-tag boolean, :end-line 273, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k]))}, remove-watch {:protocol-inline nil, :name cljs.core/remove-watch, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([iref key]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 8385, :end-line 8385, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference"}, ex-info {:protocol-inline nil, :name cljs.core/ex-info, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([msg map] [msg map cause]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 2} {:tag cljs.core/ExceptionInfo, :variadic false, :max-fixed-arity 3}), :line 9064, :end-line 9064, :max-fixed-arity 3, :fn-var true, :arglists (quote ([msg map] [msg map cause])), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data."}, ifn? {:protocol-inline nil, :name cljs.core/ifn?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([f]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1542, :ret-tag boolean, :end-line 1542, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f]))}, IAtom {:protocol-symbol true, :name cljs.core/IAtom, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 397, :protocol-info {:methods {}}, :info nil, :end-line 397, :impls #{cljs.core/Atom}}, ->PersistentQueue {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([meta count front rear __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentQueue, :variadic false, :max-fixed-arity 5}), :line 4836, :end-line 4836, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, IWatchable {:protocol-symbol true, :name cljs.core/IWatchable, :file "out/cljs/core.cljs", :end-column 25, :column 1, :line 355, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 355, :impls #{cljs.core/Atom}}, ->Stepper {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->Stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([xform iter]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Stepper, :variadic false, :max-fixed-arity 2}), :line 3071, :end-line 3071, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :skip-protocol-flag nil}, pv-fresh-node {:protocol-inline nil, :private true, :name cljs.core/pv-fresh-node, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([edit]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 1}), :line 4074, :end-line 4074, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit]))}, subvec {:protocol-inline nil, :name cljs.core/subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([v start] [v start end]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 2} {:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 3}), :line 4597, :end-line 4597, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done."}, -pop! {:protocol-inline nil, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tcoll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 373, :ret-tag clj, :end-line 375, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll]))}, partial {:protocol-inline nil, :name cljs.core/partial, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 more]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic false, :max-fixed-arity 4} {:tag function, :variadic true, :max-fixed-arity 4}), :line 3316, :end-line 3316, :max-fixed-arity 4, :fn-var true, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args."}, chunked-seq? {:protocol-inline nil, :name cljs.core/chunked-seq?, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1478, :ret-tag boolean, :end-line 1478, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, replicate {:protocol-inline nil, :name cljs.core/replicate, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([n x]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3816, :end-line 3816, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "Returns a lazy seq of n xs."}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "out/cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4836, :record false, :end-line 4836, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :name cljs.core/min-key, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([k x] [k x y] [k x y more]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic true, :max-fixed-arity 3}), :line 7587, :end-line 7587, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least."}, hash-iset {:protocol-inline nil, :private true, :name cljs.core/hash-iset, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2191, :end-line 2191, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, reduced {:protocol-inline nil, :name cljs.core/reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Reduced, :variadic false, :max-fixed-arity 1}), :line 829, :end-line 829, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, re-matches {:protocol-inline nil, :name cljs.core/re-matches, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([re s]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 7957, :end-line 7957, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, array-map {:protocol-inline nil, :name cljs.core/array-map, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([keyvals]), :protocol-impl nil, :column 1, :methods ({:variadic true, :max-fixed-arity 0}), :line 7042, :end-line 7042, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings."}, ITransientSet {:protocol-symbol true, :name cljs.core/ITransientSet, :file "out/cljs/core.cljs", :end-column 28, :column 1, :line 377, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 377, :impls #{cljs.core/TransientHashSet}}, ITER_SYMBOL {:file "out/cljs/core.cljs", :line 152, :column 3, :end-line 152, :end-column 20, :name cljs.core/ITER_SYMBOL}, unchecked-byte {:protocol-inline nil, :name cljs.core/unchecked-byte, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1892, :ret-tag number, :end-line 1892, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ArrayNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNode, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5779, :record false, :declared true, :end-line 5779, :skip-protocol-flag nil}, ->ChunkedSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 6}), :line 4406, :end-line 4406, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, every-pred {:protocol-inline nil, :name cljs.core/every-pred, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 ps]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3588, :end-line 3588, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates."}, keys {:protocol-inline nil, :name cljs.core/keys, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([hash-map]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/KeySeq clj-nil}, :variadic false, :max-fixed-arity 1}), :line 7137, :end-line 7137, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, missing-protocol {:protocol-inline nil, :name cljs.core/missing-protocol, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([proto obj]), :protocol-impl nil, :column 1, :methods ({:tag js/Error, :variadic false, :max-fixed-arity 2}), :line 135, :end-line 135, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj]))}, PersistentArrayMap {:num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 5246, :record false, :end-line 5246, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :name cljs.core/distinct?, :variadic true, :file "out/cljs/core.cljs", :end-column 26, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 1572, :ret-tag boolean, :end-line 1572, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are ="}, never-equiv {:file "out/cljs/core.cljs", :line 4901, :column 1, :end-line 4901, :end-column 28, :private true, :name cljs.core/never-equiv}, Stepper {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/Stepper, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 3071, :record false, :end-line 3071, :skip-protocol-flag nil}, unchecked-short {:protocol-inline nil, :name cljs.core/unchecked-short, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1894, :ret-tag number, :end-line 1894, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ->Range {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([meta start end step __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Range, :variadic false, :max-fixed-arity 5}), :line 7702, :end-line 7702, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta start end step __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, methods {:protocol-inline nil, :name cljs.core/methods, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([multifn]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 9023, :end-line 9023, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, odd? {:protocol-inline nil, :name cljs.core/odd?, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 3269, :ret-tag boolean, :end-line 3269, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, ->ArrayChunk {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([arr off end]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ArrayChunk, :variadic false, :max-fixed-arity 3}), :line 2580, :end-line 2580, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, lazy-transformer {:protocol-inline nil, :name cljs.core/lazy-transformer, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([stepper]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazyTransformer, :variadic false, :max-fixed-arity 1}), :line 3068, :end-line 3068, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stepper]))}, ci-reduce {:protocol-inline nil, :private true, :name cljs.core/ci-reduce, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4}), :line 855, :end-line 855, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization"}, *3 {:file "out/cljs/core.cljs", :line 65, :column 1, :end-line 67, :end-column 6, :doc "bound in a repl thread to the third most recent value printed", :name cljs.core/*3}, -get-method {:protocol-inline nil, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([mf dispatch-val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 8810, :end-line 8815, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val]))}, ->Var {:protocol-inline nil, :protocols #{cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Var, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([val sym _meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Var, :variadic false, :max-fixed-arity 3}), :line 624, :end-line 624, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IDeref}}, frequencies {:protocol-inline nil, :name cljs.core/frequencies, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 7866, :end-line 7866, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, reduceable? {:protocol-inline nil, :name cljs.core/reduceable?, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1461, :ret-tag boolean, :end-line 1461, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, string-hash-cache {:file "out/cljs/core.cljs", :line 496, :column 1, :end-line 496, :end-column 24, :name cljs.core/string-hash-cache}, rsubseq {:protocol-inline nil, :name cljs.core/rsubseq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :column 1, :methods ({:tag #{seq clj cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 3} {:tag #{cljs.core/LazySeq clj-nil}, :variadic false, :max-fixed-arity 5}), :line 7676, :end-line 7676, :max-fixed-arity 5, :fn-var true, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, inc {:protocol-inline nil, :name cljs.core/inc, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 819, :end-line 819, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, type->str {:protocol-inline nil, :name cljs.core/type->str, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([ty]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 144, :end-line 144, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty]))}, obj-clone {:protocol-inline nil, :private true, :name cljs.core/obj-clone, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([obj ks]), :protocol-impl nil, :column 1, :methods ({:tag object, :variadic false, :max-fixed-arity 2}), :line 4953, :end-line 4953, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks]))}, get-method {:protocol-inline nil, :name cljs.core/get-method, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([multifn dispatch-val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 9027, :end-line 9027, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, vector-index-out-of-bounds {:protocol-inline nil, :private true, :name cljs.core/vector-index-out-of-bounds, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([i cnt]), :protocol-impl nil, :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 2}), :line 4118, :end-line 4118, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt]))}, t5591 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t5591, :file "out/cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3003, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, es6-entries-iterator {:protocol-inline nil, :name cljs.core/es6-entries-iterator, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ES6EntriesIterator, :variadic false, :max-fixed-arity 1}), :line 5083, :end-line 5083, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, bit-clear {:protocol-inline nil, :name cljs.core/bit-clear, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 2051, :end-line 2051, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n"}, Range {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "out/cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7702, :record false, :end-line 7702, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :name cljs.core/filter, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([pred] [pred coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3876, :end-line 3876, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->PersistentTreeMapSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentTreeMapSeq, :variadic false, :max-fixed-arity 5}), :line 6370, :end-line 6370, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, create-array-node-seq {:protocol-inline nil, :private true, :name cljs.core/create-array-node-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([nodes] [meta nodes i s]), :protocol-impl nil, :column 1, :methods ({:tag #{cljs.core/ArrayNodeSeq clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{cljs.core/ArrayNodeSeq clj-nil}, :variadic false, :max-fixed-arity 4}), :line 6103, :end-line 6103, :max-fixed-arity 4, :fn-var true, :arglists (quote ([nodes] [meta nodes i s]))}, -assoc-n! {:protocol-inline nil, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll n val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 373, :ret-tag clj, :end-line 374, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val]))}, IWithMeta {:protocol-symbol true, :name cljs.core/IWithMeta, :file "out/cljs/core.cljs", :end-column 24, :column 1, :line 304, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 304, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/t5588 cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/t5591 cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, list {:protocol-inline nil, :name cljs.core/list, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([xs]), :protocol-impl nil, :column 1, :methods ({:tag not-native, :variadic true, :max-fixed-arity 0}), :line 2344, :end-line 2344, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& xs]))}, + {:protocol-inline nil, :name cljs.core/+, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([] [x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 0} {:variadic false, :max-fixed-arity 1} {:tag number, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1781, :ret-tag number, :end-line 1781, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0."}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "out/cljs/core.cljs", :end-column 29, :type true, :column 10, :line 929, :record false, :end-line 929, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :name cljs.core/split-with, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :line 7820, :end-line 7820, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, ->VectorNode {:protocol-inline nil, :protocols #{}, :name cljs.core/->VectorNode, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([edit arr]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/VectorNode, :variadic false, :max-fixed-arity 2}), :line 4072, :end-line 4072, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil}, aset {:protocol-inline nil, :name cljs.core/aset, :variadic true, :file "out/cljs/core.cljs", :end-column 12, :method-params ([array i val] [array idx idx2 idxv]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 3} {:tag any, :variadic true, :max-fixed-arity 3}), :line 186, :end-line 186, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array i val] [array idx idx2 & idxv])), :doc "Sets the value at the index."}, int-rotate-left {:protocol-inline nil, :name cljs.core/int-rotate-left, :variadic false, :file "out/cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 431, :ret-tag number, :end-line 431, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n]))}, keyword {:protocol-inline nil, :name cljs.core/keyword, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([name] [ns name]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/Keyword clj-nil}, :variadic false, :max-fixed-arity 1} {:tag cljs.core/Keyword, :variadic false, :max-fixed-arity 2}), :line 2480, :end-line 2480, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically."}, ->Cons {:protocol-inline nil, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([meta first rest __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Cons, :variadic false, :max-fixed-arity 4}), :line 2359, :end-line 2359, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, create-tree-map-seq {:protocol-inline nil, :private true, :name cljs.core/create-tree-map-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([tree ascending? cnt]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/PersistentTreeMapSeq, :variadic false, :max-fixed-arity 3}), :line 6423, :end-line 6423, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt]))}, ICollection {:protocol-symbol true, :name cljs.core/ICollection, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 251, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 251, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}}, multi-stepper {:protocol-inline nil, :name cljs.core/multi-stepper, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([xform iters] [xform iters nexts]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 3125, :end-line 3125, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters] [xform iters nexts]))}, chars {:protocol-inline nil, :name cljs.core/chars, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1997, :end-line 1997, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, str {:protocol-inline nil, :name cljs.core/str, :variadic true, :file "out/cljs/core.cljs", :end-column 11, :method-params ([] [x] [x ys]), :protocol-impl nil, :column 1, :methods ({:tag string, :variadic false, :max-fixed-arity 0} {:tag #{any string}, :variadic false, :max-fixed-arity 1} {:variadic true, :max-fixed-arity 1}), :line 2134, :end-line 2134, :max-fixed-arity 1, :fn-var true, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."}, next {:protocol-inline nil, :name cljs.core/next, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{seq clj-or-nil clj-nil}, :variadic false, :max-fixed-arity 1}), :line 690, :ret-tag seq, :end-line 690, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, ASeq {:protocol-symbol true, :name cljs.core/ASeq, :file "out/cljs/core.cljs", :end-column 19, :column 1, :line 260, :protocol-info {:methods {}}, :info nil, :end-line 260, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}}, pr-seq-writer {:protocol-inline nil, :name cljs.core/pr-seq-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([objs writer opts]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 3}), :line 8122, :end-line 8122, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts]))}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "out/cljs/core.cljs", :end-column 18, :type true, :column 10, :line 3036, :record false, :end-line 3036, :skip-protocol-flag nil}, IFn {:protocol-symbol true, :name cljs.core/IFn, :file "out/cljs/core.cljs", :end-column 18, :column 1, :line 217, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 217, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}}, regexp? {:protocol-inline nil, :name cljs.core/regexp?, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([o]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 7954, :end-line 7954, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o]))}, hash-map {:protocol-inline nil, :name cljs.core/hash-map, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([keyvals]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic true, :max-fixed-arity 0}), :line 7033, :end-line 7033, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings."}, underive {:protocol-inline nil, :name cljs.core/underive, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 8737, :end-line 8737, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, array-copy {:protocol-inline nil, :private true, :name cljs.core/array-copy, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([from i to j len]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 5}), :line 1496, :end-line 1496, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, obj-map-compare-keys {:protocol-inline nil, :private true, :name cljs.core/obj-map-compare-keys, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([a b]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 4931, :end-line 4931, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -reset! {:protocol-inline nil, :protocol cljs.core/IReset, :name cljs.core/-reset!, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 399, :end-line 400, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value]))}, -rest {:protocol-inline nil, :protocol cljs.core/ISeq, :name cljs.core/-rest, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 262, :ret-tag clj, :end-line 264, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll]))}, nil-iter {:protocol-inline nil, :name cljs.core/nil-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/t5591, :variadic false, :max-fixed-arity 0}), :line 3002, :end-line 3002, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, pr-writer {:protocol-inline nil, :private true, :name cljs.core/pr-writer, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([obj writer opts]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8051, :end-line 8051, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, false? {:protocol-inline nil, :name cljs.core/false?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1516, :ret-tag boolean, :end-line 1516, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "out/cljs/core.cljs", :end-column 25, :type true, :column 10, :line 4169, :record false, :end-line 4169, :skip-protocol-flag nil}, *print-readably* {:file "out/cljs/core.cljs", :line 34, :column 1, :end-line 34, :end-column 33, :dynamic true, :name cljs.core/*print-readably*}, ints {:protocol-inline nil, :name cljs.core/ints, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1999, :end-line 1999, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, some-fn {:protocol-inline nil, :name cljs.core/some-fn, :variadic true, :file "out/cljs/core.cljs", :end-column 15, :method-params ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 ps]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2} {:tag function, :variadic false, :max-fixed-arity 3} {:tag function, :variadic true, :max-fixed-arity 3}), :line 3627, :end-line 3627, :max-fixed-arity 3, :fn-var true, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates."}, *flush-on-newline* {:file "out/cljs/core.cljs", :line 32, :column 1, :end-line 32, :end-column 35, :dynamic true, :name cljs.core/*flush-on-newline*}, to-array {:protocol-inline nil, :name cljs.core/to-array, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1}), :line 2700, :end-line 2700, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, build-subvec {:protocol-inline nil, :private true, :name cljs.core/build-subvec, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([meta v start end __hash]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/Subvec, :variadic false, :max-fixed-arity 5}), :line 4586, :end-line 4586, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash]))}, list? {:protocol-inline nil, :name cljs.core/list?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 2416, :ret-tag boolean, :end-line 2416, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, tree-map-remove {:protocol-inline nil, :private true, :name cljs.core/tree-map-remove, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([comp tree k found]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/BlackNode clj-nil cljs.core/RedNode}, :variadic false, :max-fixed-arity 4}), :line 6852, :end-line 6852, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found]))}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/HashCollisionNode, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5885, :record false, :end-line 5885, :skip-protocol-flag nil}, array? {:protocol-inline nil, :name cljs.core/array?, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 88, :ret-tag boolean, :end-line 88, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, prefers* {:protocol-inline nil, :private true, :name cljs.core/prefers*, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table]), :protocol-impl nil, :column 1, :methods ({:tag #{boolean clj-nil}, :variadic false, :max-fixed-arity 3}), :line 8763, :end-line 8763, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, clone {:protocol-inline nil, :name cljs.core/clone, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([value]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 637, :end-line 637, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value]))}, scan-array {:protocol-inline nil, :private true, :name cljs.core/scan-array, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([incr k array]), :protocol-impl nil, :column 1, :methods ({:tag #{number clj-nil}, :variadic false, :max-fixed-arity 3}), :line 4917, :end-line 4917, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array]))}, bit-not {:protocol-inline nil, :name cljs.core/bit-not, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 2061, :end-line 2061, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement"}, quote-string {:protocol-inline nil, :private true, :name cljs.core/quote-string, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 8042, :end-line 8042, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, byte {:protocol-inline nil, :name cljs.core/byte, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1878, :ret-tag number, :end-line 1878, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, max {:protocol-inline nil, :name cljs.core/max, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic true, :max-fixed-arity 2}), :line 1864, :ret-tag number, :end-line 1864, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums."}, IComparable {:protocol-symbol true, :name cljs.core/IComparable, :file "out/cljs/core.cljs", :end-column 26, :column 1, :line 380, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 380, :impls #{cljs.core/Keyword cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol}}, == {:protocol-inline nil, :name cljs.core/==, :variadic true, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x] [x y] [x y more]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1} {:tag boolean, :variadic false, :max-fixed-arity 2} {:tag boolean, :variadic true, :max-fixed-arity 2}), :line 2098, :ret-tag boolean, :end-line 2098, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined."}, parents {:protocol-inline nil, :name cljs.core/parents, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([tag] [h tag]), :protocol-impl nil, :column 1, :methods ({:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 1} {:tag #{nil clj-nil}, :variadic false, :max-fixed-arity 2}), :line 8678, :end-line 8678, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, count {:protocol-inline nil, :name cljs.core/count, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1142, :end-line 1142, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, -disjoin! {:protocol-inline nil, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([tcoll v]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 377, :ret-tag clj, :end-line 378, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v]))}, ->TransientHashMap {:protocol-inline nil, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/TransientHashMap, :variadic false, :max-fixed-arity 5}), :line 6258, :end-line 6258, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ArrayChunk {:num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 2580, :record false, :declared true, :end-line 2580, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, sorted-map-by {:protocol-inline nil, :name cljs.core/sorted-map-by, :variadic true, :file "out/cljs/core.cljs", :end-column 21, :method-params ([comparator keyvals]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/PersistentTreeMap, :variadic true, :max-fixed-arity 1}), :line 7070, :end-line 7070, :max-fixed-arity 1, :fn-var true, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator."}, apply {:protocol-inline nil, :name cljs.core/apply, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([f args] [f x args] [f x y args] [f x y z args] [f a b c d args]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4} {:tag #{nil any}, :variadic false, :max-fixed-arity 5} {:tag #{nil any}, :variadic true, :max-fixed-arity 5}), :line 2926, :end-line 2926, :max-fixed-arity 5, :fn-var true, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.\n  First cut.  Not lazy.  Needs to use emitted toApply."}, get-global-hierarchy {:protocol-inline nil, :private true, :name cljs.core/get-global-hierarchy, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 0}), :line 8650, :end-line 8650, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, add-to-string-hash-cache {:protocol-inline nil, :name cljs.core/add-to-string-hash-cache, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([k]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 511, :end-line 511, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, clj->js {:protocol-inline nil, :name cljs.core/clj->js, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil object any array string clj-nil}, :variadic false, :max-fixed-arity 1}), :line 8530, :end-line 8530, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."}, TransientArrayMap {:num-fields 3, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "out/cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5426, :record false, :declared true, :end-line 5426, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->TransientVector {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([cnt shift root tail]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/TransientVector, :variadic false, :max-fixed-arity 4}), :line 4663, :end-line 4663, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, IChunkedNext {:protocol-symbol true, :name cljs.core/IChunkedNext, :file "out/cljs/core.cljs", :end-column 27, :column 1, :line 390, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 390, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}}, interpose {:protocol-inline nil, :name cljs.core/interpose, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([sep coll]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3846, :end-line 3846, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep"}, ->BlackNode {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([key val left right __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/BlackNode, :variadic false, :max-fixed-arity 5}), :line 6529, :end-line 6529, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, deref {:file "out/cljs/core.cljs", :line 5507, :column 1, :end-line 5507, :end-column 79, :declared true, :name cljs.core/deref}, pv-aget {:protocol-inline nil, :private true, :name cljs.core/pv-aget, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([node idx]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 4077, :end-line 4077, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx]))}, assoc {:protocol-inline nil, :name cljs.core/assoc, :variadic true, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll k v] [coll k v kvs]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic true, :max-fixed-arity 3}), :line 1299, :end-line 1299, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index."}, transient {:protocol-inline nil, :name cljs.core/transient, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :line 2855, :end-line 2855, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, -disjoin {:protocol-inline nil, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([coll v]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 285, :ret-tag clj, :end-line 286, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v]))}, chunk-cons {:protocol-inline nil, :name cljs.core/chunk-cons, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([chunk rest]), :protocol-impl nil, :column 1, :methods ({:tag #{nil cljs.core/ChunkedCons}, :variadic false, :max-fixed-arity 2}), :line 2676, :end-line 2676, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest]))}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3021, :record false, :end-line 3021, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :name cljs.core/comparator, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 9098, :end-line 9098, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, sorted-map {:protocol-inline nil, :name cljs.core/sorted-map, :variadic true, :file "out/cljs/core.cljs", :end-column 18, :method-params ([keyvals]), :protocol-impl nil, :column 1, :methods ({:variadic true, :max-fixed-arity 0}), :line 7061, :end-line 7061, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings."}, drop-while {:protocol-inline nil, :name cljs.core/drop-while, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([pred] [pred coll]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3775, :end-line 3775, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided."}, IWriter {:protocol-symbol true, :name cljs.core/IWriter, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 340, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 340, :impls #{cljs.core/StringBufferWriter}}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "out/cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7080, :record false, :end-line 7080, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :name cljs.core/realized?, :variadic false, :file "out/cljs/core.cljs", :end-column 26, :method-params ([d]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 8436, :ret-tag boolean, :end-line 8436, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}, array-map-index-of-keyword? {:protocol-inline nil, :private true, :name cljs.core/array-map-index-of-keyword?, :variadic false, :file "out/cljs/core.cljs", :end-column 36, :method-params ([arr m k]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 3}), :line 5109, :end-line 5109, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr m k]))}, *print-fn* {:protocol-inline nil, :name cljs.core/*print-fn*, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([_]), :protocol-impl nil, :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 1}), :dynamic true, :line 20, :end-line 24, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, compare {:protocol-inline nil, :name cljs.core/compare, :variadic false, :file "out/cljs/core.cljs", :end-column 23, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 1598, :ret-tag number, :end-line 1598, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, complement {:protocol-inline nil, :name cljs.core/complement, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([f]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 3273, :ret-tag boolean, :end-line 3273, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, lookup-sentinel {:file "out/cljs/core.cljs", :line 1514, :column 1, :end-line 1514, :end-column 32, :private true, :name cljs.core/lookup-sentinel}, -assoc! {:protocol-inline nil, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([tcoll key val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 3}), :line 367, :ret-tag clj, :end-line 368, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val]))}, *print-dup* {:file "out/cljs/core.cljs", :line 36, :column 1, :end-line 36, :end-column 28, :dynamic true, :name cljs.core/*print-dup*}, string-iter {:protocol-inline nil, :name cljs.core/string-iter, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/StringIter, :variadic false, :max-fixed-arity 1}), :line 3018, :end-line 3018, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -key->js {:protocol-inline nil, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 8513, :end-line 8515, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, IDeref {:protocol-symbol true, :name cljs.core/IDeref, :file "out/cljs/core.cljs", :end-column 21, :column 1, :line 295, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 295, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}}, sequence {:protocol-inline nil, :name cljs.core/sequence, :variadic true, :file "out/cljs/core.cljs", :end-column 16, :method-params ([coll] [xform coll] [xform coll colls]), :protocol-impl nil, :column 1, :methods ({:tag #{nil seq cljs.core/IList}, :variadic false, :max-fixed-arity 1} {:variadic false, :max-fixed-arity 2} {:variadic true, :max-fixed-arity 2}), :line 3217, :end-line 3217, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"}, constantly {:protocol-inline nil, :name cljs.core/constantly, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 3283, :end-line 3283, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, ->RangedIterator {:protocol-inline nil, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([i base arr v start end]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/RangedIterator, :variadic false, :max-fixed-arity 6}), :line 4169, :end-line 4169, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil}, chunked-seq {:protocol-inline nil, :name cljs.core/chunked-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 19, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 3} {:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 4} {:tag cljs.core/ChunkedSeq, :variadic false, :max-fixed-arity 5}), :line 4482, :end-line 4482, :max-fixed-arity 5, :fn-var true, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta]))}, ISorted {:protocol-symbol true, :name cljs.core/ISorted, :file "out/cljs/core.cljs", :end-column 22, :column 1, :line 334, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 334, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}}, make-array {:protocol-inline nil, :name cljs.core/make-array, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([size] [type size]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag array, :variadic false, :max-fixed-arity 2}), :line 156, :ret-tag array, :end-line 156, :max-fixed-arity 2, :tag array, :fn-var true, :arglists (quote ([size] [type size]))}, shorts {:protocol-inline nil, :name cljs.core/shorts, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1998, :end-line 1998, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, *unchecked-if* {:file "out/cljs/core.cljs", :line 18, :column 1, :end-line 18, :end-column 21, :name cljs.core/*unchecked-if*}, ->RSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([ci i meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/RSeq, :variadic false, :max-fixed-arity 3}), :line 1023, :end-line 1023, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, enable-console-print! {:protocol-inline nil, :name cljs.core/enable-console-print!, :variadic false, :file "out/cljs/core.cljs", :end-column 29, :method-params ([]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 0}), :line 49, :end-line 49, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, -flush {:protocol-inline nil, :protocol cljs.core/IWriter, :name cljs.core/-flush, :variadic false, :file "out/cljs/core.cljs", :end-column 11, :method-params ([writer]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 340, :end-line 342, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer]))}, completing {:protocol-inline nil, :name cljs.core/completing, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([f] [f cf]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1} {:tag function, :variadic false, :max-fixed-arity 2}), :line 1755, :end-line 1755, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f] [f cf]))}, unchecked-negate-int {:protocol-inline nil, :name cljs.core/unchecked-negate-int, :variadic false, :file "out/cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1948, :end-line 1948, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->PersistentVector {:protocol-inline nil, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentVector, :variadic false, :max-fixed-arity 6}), :line 4191, :end-line 4191, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, equiv-sequential {:protocol-inline nil, :private true, :name cljs.core/equiv-sequential, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([x y]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 2156, :end-line 2156, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, hash-unordered-coll {:protocol-inline nil, :name cljs.core/hash-unordered-coll, :variadic false, :file "out/cljs/core.cljs", :end-column 35, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 773, :ret-tag number, :end-line 773, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, repeat {:protocol-inline nil, :name cljs.core/repeat, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :method-params ([x] [n x]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1} {:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 3811, :end-line 3811, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs."}, unchecked-inc {:protocol-inline nil, :name cljs.core/unchecked-inc, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 1925, :end-line 1925, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, nthnext {:protocol-inline nil, :name cljs.core/nthnext, :variadic false, :file "out/cljs/core.cljs", :end-column 15, :method-params ([coll n]), :protocol-impl nil, :column 1, :methods ({:tag seq, :variadic false, :max-fixed-arity 2}), :line 2124, :end-line 2124, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, preserving-reduced {:protocol-inline nil, :private true, :name cljs.core/preserving-reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 27, :method-params ([rf]), :protocol-impl nil, :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 8441, :end-line 8441, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf]))}, get-validator {:protocol-inline nil, :name cljs.core/get-validator, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([iref]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 3525, :end-line 3525, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3009, :record false, :end-line 3009, :skip-protocol-flag nil}, number? {:protocol-inline nil, :name cljs.core/number?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([n]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 91, :ret-tag boolean, :end-line 91, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n]))}, -conj! {:protocol-inline nil, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :variadic false, :file "out/cljs/core.cljs", :end-column 16, :method-params ([tcoll val]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 363, :ret-tag clj, :end-line 364, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val]))}, ->PersistentArrayMapSeq {:protocol-inline nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :variadic false, :file "out/cljs/core.cljs", :end-column 32, :method-params ([arr i _meta]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/PersistentArrayMapSeq, :variadic false, :max-fixed-arity 3}), :line 5176, :end-line 5176, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, chunk-next {:protocol-inline nil, :name cljs.core/chunk-next, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag #{nil seq any}, :variadic false, :max-fixed-arity 1}), :line 2693, :end-line 2693, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "out/cljs/core.cljs", :end-column 20, :type true, :column 10, :line 7594, :record false, :end-line 7594, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :name cljs.core/print-str, :variadic true, :file "out/cljs/core.cljs", :end-column 17, :method-params ([objs]), :protocol-impl nil, :column 1, :methods ({:tag #{nil string}, :variadic true, :max-fixed-arity 0}), :line 8188, :end-line 8188, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& objs])), :doc "print to a string, returning it"}, not-any? {:protocol-inline nil, :name cljs.core/not-any?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([pred coll]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 3258, :ret-tag boolean, :end-line 3258, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, into-array {:protocol-inline nil, :name cljs.core/into-array, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([aseq] [type aseq]), :protocol-impl nil, :column 1, :methods ({:tag array, :variadic false, :max-fixed-arity 1} {:tag any, :variadic false, :max-fixed-arity 2}), :line 200, :ret-tag array, :end-line 200, :max-fixed-arity 2, :tag array, :fn-var true, :arglists (quote ([aseq] [type aseq]))}, -hash {:protocol-inline nil, :protocol cljs.core/IHash, :name cljs.core/-hash, :variadic false, :file "out/cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 316, :end-line 317, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o]))}, -dissoc! {:protocol-inline nil, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([tcoll key]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2}), :line 370, :ret-tag clj, :end-line 371, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key]))}, ->Reduced {:protocol-inline nil, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :variadic false, :file "out/cljs/core.cljs", :end-column 18, :method-params ([val]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/Reduced, :variadic false, :max-fixed-arity 1}), :line 825, :end-line 825, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}}, chunk-buffer {:protocol-inline nil, :name cljs.core/chunk-buffer, :variadic false, :file "out/cljs/core.cljs", :end-column 20, :method-params ([capacity]), :protocol-impl nil, :column 1, :methods ({:tag cljs.core/ChunkBuffer, :variadic false, :max-fixed-arity 1}), :line 2577, :end-line 2577, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity]))}, seqable? {:protocol-inline nil, :name cljs.core/seqable?, :variadic false, :file "out/cljs/core.cljs", :end-column 25, :method-params ([s]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1534, :ret-tag boolean, :end-line 1534, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable"}, symbol? {:protocol-inline nil, :name cljs.core/symbol?, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 559, :ret-tag boolean, :end-line 559, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, m3-hash-unencoded-chars {:protocol-inline nil, :name cljs.core/m3-hash-unencoded-chars, :variadic false, :file "out/cljs/core.cljs", :end-column 39, :method-params ([in]), :protocol-impl nil, :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 1}), :line 477, :ret-tag number, :end-line 477, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, unchecked-char {:protocol-inline nil, :name cljs.core/unchecked-char, :variadic false, :file "out/cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1893, :ret-tag number, :end-line 1893, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "out/cljs/core.cljs", :end-column 21, :type true, :column 10, :line 4894, :record false, :end-line 4894, :skip-protocol-flag #{cljs.core/IEquiv}}, -invoke {:protocol-inline nil, :protocol cljs.core/IFn, :name cljs.core/-invoke, :variadic false, :file "out/cljs/core.cljs", :end-column 12, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1} {:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 3} {:tag #{nil any}, :variadic false, :max-fixed-arity 4} {:tag #{nil any}, :variadic false, :max-fixed-arity 5} {:tag #{nil any}, :variadic false, :max-fixed-arity 6} {:tag #{nil any}, :variadic false, :max-fixed-arity 7} {:tag #{nil any}, :variadic false, :max-fixed-arity 8} {:tag #{nil any}, :variadic false, :max-fixed-arity 9} {:tag #{nil any}, :variadic false, :max-fixed-arity 10} {:tag #{nil any}, :variadic false, :max-fixed-arity 11} {:tag #{nil any}, :variadic false, :max-fixed-arity 12} {:tag #{nil any}, :variadic false, :max-fixed-arity 13} {:tag #{nil any}, :variadic false, :max-fixed-arity 14} {:tag #{nil any}, :variadic false, :max-fixed-arity 15} {:tag #{nil any}, :variadic false, :max-fixed-arity 16} {:tag #{nil any}, :variadic false, :max-fixed-arity 17} {:tag #{nil any}, :variadic false, :max-fixed-arity 18} {:tag #{nil any}, :variadic false, :max-fixed-arity 19} {:tag #{nil any}, :variadic false, :max-fixed-arity 20} {:tag #{nil any}, :variadic false, :max-fixed-arity 21} {:tag #{nil any}, :variadic false, :max-fixed-arity 22}), :line 217, :end-line 218, :max-fixed-arity 22, :fn-var true, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]))}, coll? {:protocol-inline nil, :name cljs.core/coll?, :variadic false, :file "out/cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 1435, :ret-tag boolean, :end-line 1435, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, get-in {:protocol-inline nil, :added "1.2", :name cljs.core/get-in, :variadic false, :file "out/cljs/core.cljs", :end-column 14, :static true, :method-params ([m ks] [m ks not-found]), :protocol-impl nil, :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:variadic false, :max-fixed-arity 3}), :line 3997, :end-line 3997, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, fnext {:protocol-inline nil, :name cljs.core/fnext, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 1093, :end-line 1093, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, IList {:protocol-symbol true, :name cljs.core/IList, :file "out/cljs/core.cljs", :end-column 20, :column 1, :line 325, :protocol-info {:methods {}}, :info nil, :end-line 325, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}}, List {:num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "out/cljs/core.cljs", :end-column 15, :type true, :column 10, :line 2214, :record false, :declared true, :end-line 2214, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -val {:protocol-inline nil, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :variadic false, :file "out/cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 281, :end-line 283, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, bytes {:protocol-inline nil, :name cljs.core/bytes, :variadic false, :file "out/cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :column 1, :methods ({:variadic false, :max-fixed-arity 1}), :line 1996, :end-line 1996, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ObjMap {:protocol-inline nil, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :variadic false, :file "out/cljs/core.cljs", :end-column 17, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :column 1, :factory :positional, :methods ({:tag cljs.core/ObjMap, :variadic false, :max-fixed-arity 5}), :line 4963, :end-line 4963, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, compare-symbols {:protocol-inline nil, :private true, :name cljs.core/compare-symbols, :variadic false, :file "out/cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :column 1, :methods ({:tag #{any number}, :variadic false, :max-fixed-arity 2}), :line 567, :end-line 567, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -seq {:protocol-inline nil, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :variadic false, :file "out/cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 319, :ret-tag clj-or-nil, :end-line 320, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o]))}}, :imports {StringBuffer goog.string.StringBuffer}, :require-macros nil, :use-macros nil, :requires {StringBuffer goog.string.StringBuffer, garray goog.array, goog.array goog.array, gobject goog.object, goog.object goog.object, goog.string goog.string, gstring goog.string}, :uses nil, :excludes #{}, :doc nil, :name cljs.core}