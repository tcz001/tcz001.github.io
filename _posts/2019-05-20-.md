---
layout: post
published: false
title: 索引-通往大规模数据的任意门
---
## 大规模数据呈现时的困难

由于小生不是什么”大数据“专家，所以这篇文章主要还是从一个微服务与区块链经验者的视角来谈谈大规模数据呈现时的困难。但这也不妨碍我们将这些知识触类旁通地应用到”大数据“领域。

过去很少有人会把区块链看做大数据的一个相关领域，因为大部分的区块链开发者还是围绕共识协议在做文章，不过大家应该都知道，区块链上主要存放的还是一些交易信息，这些数据几乎都被trim到了极致，每个byte应该存放什么样的信息，都被“安排的明明白白”，因此“数据工程师”们喜闻乐见的数据清洗和ETL工具在这里几乎毫无必要存在。但是在数据分析方面，基于区块链构建的业务却常常遇到一个“大规模优质数据”带来的“幸福烦恼”，那就是动辄数百GB的存储在呈现时引发的“性能问题”。

当我们把区块链抽象地看做事务（transaction）的记录，每一次交易记录以区块（block）为单元组织成一串牢不可破的链（chain），最后就形成了一本账（ledger）。这就是我们常说的区块链底层数据结构。这样的数据经过经年累月，可以积累数以亿万记的交易记录。

![以太坊加密猫可视化图谱](以太坊加密猫可视化图谱.png)

（图为以太坊加密猫可视化图谱）

抛开复杂的同步与共识逻辑，单纯从数据结构来看，分布式账本其实只是按时间序列组成的事务日志（Transaction log），或者针对UTXO类型账本而言，则是形成了一系列的有向图（directional graph）。这样的数据结构原本是为了便于解决数据不可篡改的溯源性，以及同步时的拜占庭容错，然而在上层构建真正的商业逻辑时，我们却很难单纯依靠这种数据结构响应复杂业务。

例如最常见的一个需求——“查询某个账户中所有满足特定条件的的交易记录”，就如同要在浩瀚星空中找到某个星座一样，需要依靠额外的星盘来完成这类检索操作，为了实现高效筛查相关交易，也需要引入额外的工具。

![astrology](astrologychart.jpg)


## 一些常见的索引

在数据库的设计中，很多功能会依赖一项技术，“索引”（Index）。

相信对数据库性能优化或是底层原理有接触的朋友，对索引一定不陌生，在各类型的SQL或是NoSQL数据库中，索引总是充当着非常关键的角色。

在索引的结构选择上，我们常常可以见到两类基本的索引技术：哈希和树。

## 哈希型索引

### 散列表 Hashtable
 
Hashtable 型如其名，是一个哈希表，它将数据转换为统一长度的摘要，用于作为表的索引，将复杂的比较
`{A1，A2, A3 ..., Ai} == {B1, B2, B3 ..., Bi}` 转换为分为两段式的查找:

1. `H({A1，A2, A3 ..., Ai}) == hash`
2. `Table(hash) == {B1, B2, B3 ..., Bi}`

通过这一次分段查找，可以有效减少遍历的时间，对于单个索引且原条件数据空间远大于索引空间的场景非常适宜。Hashtable常常依赖分布均匀且计算效率高的散列算法，如jenkins-hash、SpookyHash等。这些算法与我们常见的密码学哈希（MD5、SHA等）有着很大的差异，前者与后者的目标也有很大的不同，密码学哈希由于常常需要代替随机预言机（Random Oracle）作为密码学的基本原语使用，因此有着额外的安全设计，这些设计对性能往往存在影响。因此挑选一种合适的哈希算法，也是在构建索引时需要考虑的事情。

![hashtable](hashtable.jpg)

### 布隆过滤器 Bloom Filter

在更为大量的数据面前，我们常常需要使用过滤器来配合传统的索引进行搜索优化。

布隆过滤器（Bloom Filter）由一系列随机映射函数Hash)组成，这些随机映射函数可以将加入集合的元素过滤为一个很长的二进制向量（即若干个`0|1`的序列），检索时，我们只要看看这些结果是不是都是`1`就知道集合中有没有它了：如果这些点有任何一个`0`，则被检元素一定不在；如果都是`1`，则被检元素“很可能”在。这就是布隆过滤器的基本思想。

![hashtable](bloomfilter.jpg)

布隆过滤器牺牲了少量的准确性和遍历时间就换取了更好的搜索效率，同时也省去了静态索引的空间开销。在针对空间上分布均匀的数据的筛查方面，相比于持久化索引有着无可比拟的优势。

### Hashtable 与 Bloom Filter 的场景化应用

其实不难发现，不管是 Hashtable 还是 Bloom Filter 都需要依赖哈希函数，而 Bloom Filter 与 HashTable 最大的不同就是空间复杂度与准确性上的差异，Hashtable 可以存放更完整的摘要信息，因而空间复杂度较高，准确性也较高。而 Bloom Filter 则可以用于快速过滤掉不满足条件的区块，我们常常需要组合这两种数据结构，来为筛查提高效率。

基于哈希函数的索引和过滤器都可以提供相对更优秀的“写入性能”（write performance）与“归一性”（normalization），也就是说，我们可以很方便地将新的记录加入到现有的索引中，而无需消耗大量的时间来修正索引数据，这无疑对于满足Append-only，同时对写入性能有较高要求的场景更加适用。但是由于哈希散列算法的原生要求，这种数据结构需要预先占用相对大的空间，同时也要求索引字段本身的信息熵（entropy）相对较高时才有更好的空间使用率，例如对于布尔型或枚举型字段这种极端的例子来说，使用哈希型索引可能就显得很浪费了。

## 树型索引

### B-Tree, B+Tree 与 B*Tree

与哈希表与Bloom过滤器不同，在优化查询方面，我们还是需要采用B-Tree的数据结构来组织索引，常见的如B-Tree使用排序后的树状索引减少了指针在二分法查询中的时间复杂度。

B-Tree 是一种自平衡树状数据结构，它维护排序数据并允许以“对数时间”进行搜索，顺序访问，插入和删除。B-Tree 非常适合于读取和写入相对较大的数据块（如磁盘）的存储系统。它通常用于数据库和文件系统的索引，尤其是在“连续存储”的环境下，通过B+ Tree和B* Tree等改良结构，减少IO读取优化连续数据块的搜索性能。

我们通过下面的动画，可以更加形象地理解 B-Tree 索引是如何完成更新的，

![btree](index_insert.gif)

使用非单调的字段（如业务字段或uuid等）作为主键在 InnoDB 引擎中并不算是个好主意，因为 InnoDB 数据文件本身是一棵 B-Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B-Tree 的特性而频繁的分裂调整，十分低效。同样反过来说，使用单调字段作为主键则是一个很好的选择，因为不会影响写入的性能。

### Block Range Index

PostgreSQL针对一些存储的特性，实现了一种特殊的索引结构，BRIN（Block range index），不同于传统的B-Tree索引，块级索引并不是以行号为单位记录索引明细，而是记录每个数据块或者每段连续的数据块的统计信息。因此BRIN索引空间占用特别的小，对数据写入、更新、删除的影响也很小。由于其属于有损的索引结构，当被索引列的值与物理存储相关性很强时，BRIN索引的效果非常的好。例如时序数据，在时间或序列字段创建BRIN索引，进行等值、范围查询时效果突出。

### Trie / Radix & Prefix Tree

以太坊里的专有数据结构 Trie，是 Radix Tree（基数树）或者 Prefix Tree（前缀树）的一种分支，由后者改进而来，为了理解这种数据结构，我们需要先了解一下基数树。

下图展示了基数树是如何帮助我们检索文本数据的：

![radix](radix.png)


基数可以理解为可以用多个元素表达一个值的分拆方法，最常见的基数树就是字典树。字典树可以简单地理解为，将字符串拆分为字母表（alphabet）的树状索引，由此可以解决数据的分布与前序模糊匹配等问题，但是字典序可能存在着一些分布不均匀的问题，因此我们常常可以看到字典序会配合hash算法，进行分布散列化，即将原本可能存在的“以a为开头的值，远多于以z开头的值”这一现象，转变为随机化分布的hex基数。

在以太坊中，Merkel Patricia Trie 就是这样的一种改良后的数据结构，通过将键值散列化（在以太坊中该键值主要为账户与合约地址、交易地址），再建立基数树索引，来避免某些分支高度过高的问题，以匹配常规存储系统的读写能力。

![merkle](merkle_patricia_tree.png)

### R-Tree Spatial Index

空间索引是一种特殊的针对空间的索引格式，在大部分地理信息系统（Geometric Information System）甚至空间系统中，由于数据结构与文本型数据表现大不相同，我们需要寻求其他的数据组织方式进行快速的检索。

空间数据，尤其是稀疏的矩阵结构，需要使用一些格式压缩成相对稠密的数据，来解决存储空间问题。常见的稀疏矩阵存储压缩格式有COO,CSR,DIA,ELL,HYB等等，每种格式所适应的数据分布场景并不相同，因此也需要根据具体的场景进行选择。例如CSR由于其数值，列号，以及行偏移的存储结构，更适合于随机或非结构化分布的稀疏矩阵，并且也更适合内存中的读写。而DIA更适合对角性高的结构化矩阵。

对于这类空间数据的索引构建，也有一些特殊性，例如

![rtree](rtree.png)

![rtree](rtree_explained.png)


## 其他类型的索引

### bitmap

Bitmap是一种有趣的特殊索引类型

![bitmap](bitmap.jpg)


## 构建索引的方法

### 冷热分离的数据索引构建方式

构建索引是一个相对精细的活动，但是很幸运的，我们发现由于稳定后的冷数据（例如区块链上距离最新高度较远的数据）本质上依然是一个Append-only数据，我们可以使用已经相对成熟的索引引擎来对这部分数据索引进行运算和存储。

针对热数据的高效过滤，我们通常会使用基于事件或消息的流式处理模型，但是不可避免的，在流式处理过程中，可能会存在一些查询需求，那么这些行为在读写互斥的一致性约束下，也很容易引发阻塞。由此我们可能需要引入一些更健壮的编排原则，将这些查询行为与存储行为隔离开来。



### 持久化索引 与 In-memory索引



## 从 Google Spanner 看分布式存储与索引的发展趋势

最近很火的几个NewSQL数据库，从Google Spanner、CockroachDB，到一些国产包括tidb、阿里的OceanDB等等，都不约而同地指向了一个困扰了大规模数据拥有者的问题，那就是分布式存储与分布式查询之间的鸿沟。

而区块链作为一个CA（一致性、高可用），但是一直P（分区容错）不起来的数据存储新星，在这个层面上是否有可以参考这些新型存储的空间。我们不妨从它们的老大哥 Spanner 谈起。

